<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Justax - Interaktivní Výuka</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <script>
        if (typeof window.MathJax === 'undefined') {
            window.MathJax = {
                tex: {
                    inlineMath: [ ['\\(', '\\)'], ['$', '$'] ],
                    displayMath: [['$$', '$$']],
                    processEscapes: true, processEnvironments: true
                },
                options: { skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'], ignoreHtmlClass: 'tex2jax_ignore', processHtmlClass: 'tex2jax_process' },
                startup: {
                    ready: () => {
                        MathJax.startup.defaultReady();
                        MathJax.startup.promise.then(() => console.log('MathJax loaded and ready.'));
                    }
                }
            };
        } else {
            console.warn("window.MathJax already defined. Skipping configuration.");
        }
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tooltipster/4.2.8/css/tooltipster.bundle.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tooltipster/4.2.8/js/tooltipster.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@excalidraw/excalidraw@0.17.3/dist/excalidraw.production.min.js" crossorigin></script>

    <style>
        /* --- CSS Styly --- */
        /* (Styly zůstávají stejné jako v původním souboru) */
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Poppins', sans-serif; scroll-behavior: smooth; }
        :root { --primary-rgb: 67, 97, 238; --primary: #4361ee; --primary-light: #4895ef; --secondary: #3f37c9; --success: #06d6a0; --danger: #f72585; --warning: #f8961e; --info: #4cc9f0; --dark: #1e2a3a; --light: #f8f9fa; --gray: #6c757d; --gray-light: #dee2e6; --gray-dark: #343a40; --gradient-1: linear-gradient(135deg, #4361ee, #3a0ca3); --gradient-2: linear-gradient(135deg, #4cc9f0, #4361ee); --white: #ffffff; --sidebar-width: 260px; --transition-speed: 0.3s; --card-radius: 14px; --shadow-sm: 0 2px 6px rgba(0, 0, 0, 0.05); --shadow-md: 0 5px 12px rgba(0, 0, 0, 0.07); --shadow-lg: 0 10px 20px rgba(0, 0, 0, 0.1); --text-primary: #2d3748; --text-secondary: #4a5568; --text-muted: #718096; --call-bg: #f9fafb; --call-panel-bg: var(--white); --avatar-size: 40px; }
        body { background-color: var(--call-bg); color: var(--text-primary); min-height: 100vh; display: flex; overflow: hidden; font-size: 15px; }
        .sidebar { width: var(--sidebar-width); height: 100vh; position: fixed; top: 0; left: 0; background: var(--gradient-1); color: var(--white); padding: 1.5rem 1rem; display: flex; flex-direction: column; z-index: 1050; box-shadow: var(--shadow-lg); transition: transform var(--transition-speed) ease, width var(--transition-speed) ease; }
        .sidebar-header { display: flex; align-items: center; margin-bottom: 2rem; padding: 0 0.75rem; } .sidebar-logo { font-size: 1.6rem; font-weight: 700; color: var(--white); text-decoration: none; display: flex; align-items: center; gap: 0.8rem; transition: transform 0.2s ease; } .sidebar-logo:hover { transform: scale(1.03); } .sidebar-logo i { font-size: 1.8rem; } .sidebar-menu { list-style: none; padding: 0; margin: 0; flex-grow: 1; } .sidebar-item { margin-bottom: 0.5rem; } .sidebar-link { display: flex; align-items: center; padding: 0.85rem 1.1rem; color: rgba(255, 255, 255, 0.9); text-decoration: none; border-radius: 10px; transition: all 0.2s ease; font-weight: 500; position: relative; } .sidebar-link i { margin-right: 0.8rem; font-size: 1.25rem; width: 24px; text-align: center; transition: transform 0.2s ease; } .sidebar-link.active, .sidebar-link:hover { background-color: rgba(255, 255, 255, 0.2); color: var(--white); } .sidebar-link:hover i { transform: scale(1.1); } .sidebar-link.active::before { content: ''; position: absolute; left: 0; top: 50%; transform: translateY(-50%); width: 4px; height: 65%; background-color: var(--white); border-radius: 0 4px 4px 0; } .sidebar-footer { margin-top: auto; padding: 1rem; font-size: 0.85rem; color: rgba(255, 255, 255, 0.7); text-align: center; } .user-profile { display: flex; align-items: center; padding: 1rem; margin-top: 1rem; background-color: rgba(255, 255, 255, 0.1); border-radius: 10px; border: 1px solid rgba(255, 255, 255, 0.15); } .user-avatar { width: 42px; height: 42px; border-radius: 50%; background-color: var(--primary-light); display: flex; align-items: center; justify-content: center; margin-right: 0.8rem; font-weight: 500; overflow: hidden; color: var(--white); border: 2px solid rgba(255, 255, 255, 0.4); } .user-avatar img { width: 100%; height: 100%; object-fit: cover; } .user-info { flex-grow: 1; line-height: 1.3; } .user-name { font-weight: 600; font-size: 0.95rem; } .user-role { font-size: 0.8rem; opacity: 0.8; }
        main { flex: 1; margin-left: var(--sidebar-width); transition: margin var(--transition-speed) ease; width: calc(100% - var(--sidebar-width)); height: 100vh; display: flex; flex-direction: column; overflow: hidden; background-color: var(--call-bg); }
        .main-header { padding: 1rem 1.75rem; background-color: var(--white); box-shadow: 0 2px 4px rgba(0,0,0,0.04); display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; z-index: 100; border-bottom: 1px solid var(--gray-light); }
        .header-content h1 { font-size: 1.5rem; font-weight: 600; color: var(--dark); margin: 0; } .header-actions button, .header-actions a { font-size: 0.9rem; padding: 0.6rem 1.2rem; }
        .topic-loading-bar { padding: 0.9rem 1.75rem; background-color: var(--light); border-bottom: 1px solid var(--gray-light); display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 1rem; flex-shrink: 0; }
        #current-topic-display { font-size: 1.05rem; font-weight: 500; color: var(--text-secondary); } #current-topic-display strong { color: var(--primary); font-weight: 600; } #current-topic-display .placeholder { font-style: italic; color: var(--text-muted); } #current-topic-display .fa-spinner { margin-right: 0.5rem; }
        .call-interface { flex-grow: 1; display: flex; overflow: hidden; padding: 1.5rem; gap: 1.5rem; }
        .ai-presenter-area { flex-grow: 1; display: flex; flex-direction: column; background-color: var(--call-panel-bg); border-radius: var(--card-radius); box-shadow: var(--shadow-md); overflow: hidden; border: 1px solid var(--gray-light); min-width: 300px; transition: box-shadow var(--transition-speed) ease; height: 100%; min-height: 0; } /* Removed duplicate overflow: hidden */
        .ai-presenter-area:hover { box-shadow: var(--shadow-lg); } .ai-presenter-header { padding: 0.8rem 1.25rem; border-bottom: 1px solid var(--gray-light); display: flex; align-items: center; gap: 0.8rem; background-color: #fdfdff; flex-shrink: 0; } .ai-avatar-placeholder { width: var(--avatar-size); height: var(--avatar-size); background: var(--gradient-1); border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-size: 1.5rem; flex-shrink: 0; box-shadow: var(--shadow-sm); } .ai-presenter-info h2 { font-size: 1.1rem; font-weight: 600; color: var(--dark); margin: 0; } .ai-presenter-info p { font-size: 0.85rem; color: var(--text-secondary); margin: 0; }
        #excalidraw-container { flex-grow: 1; position: relative; overflow: hidden; border-radius: 0 0 var(--card-radius) var(--card-radius); background-color: var(--white); min-height: 0; display: flex; box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.04); }
        #excalidraw-container > .excalidraw-wrapper { width: 100% !important; height: 100% !important; display: flex !important; flex-direction: column !important; } #excalidraw-container .excalidraw { width: 100% !important; height: 100% !important; min-height: 350px; border: none !important; flex-grow: 1 !important; } #excalidraw-container .loading-placeholder { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; flex-direction: column; color: var(--text-muted); background-color: var(--white); z-index: 5; } #excalidraw-container .loading-placeholder i { font-size: 2.5rem; color: var(--primary); margin-bottom: 1rem; animation: spinPulse 2s infinite ease-in-out; } #excalidraw-container .loading-placeholder p { font-size: 1rem; } @keyframes spinPulse { 0% { transform: scale(1) rotate(0deg); opacity: 0.7; } 50% { transform: scale(1.1) rotate(180deg); opacity: 1; } 100% { transform: scale(1) rotate(360deg); opacity: 0.7; } }
        .interaction-panel { width: 400px; flex-shrink: 0; display: flex; flex-direction: column; background-color: var(--call-panel-bg); border-radius: var(--card-radius); box-shadow: var(--shadow-md); overflow: hidden; border: 1px solid var(--gray-light); transition: box-shadow 0.3s ease; height: 100%; min-height: 0; }
        .interaction-panel:hover { box-shadow: var(--shadow-lg); } .interaction-tabs { display: flex; border-bottom: 1px solid var(--gray-light); background-color: #fdfdff; flex-shrink: 0; } .interaction-tab { flex: 1; text-align: center; padding: 0.9rem 1rem; font-weight: 500; color: var(--text-secondary); cursor: pointer; transition: all 0.2s ease; border-bottom: 3px solid transparent; font-size: 0.95rem; position: relative; } .interaction-tab:hover { color: var(--primary); background-color: rgba(var(--primary-rgb), 0.03); } .interaction-tab.active { color: var(--primary); border-bottom-color: var(--primary); font-weight: 600; background-color: var(--call-panel-bg); } .interaction-tab i { margin-right: 0.5rem; font-size: 1.05em; }
        .interaction-content-area { flex-grow: 1; overflow: hidden; position: relative; background-color: var(--call-panel-bg); min-height: 0; }
        .tab-content { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; overflow: hidden; visibility: hidden; opacity: 0; transition: opacity 0.3s ease, visibility 0s linear 0.3s; } .tab-content.active { visibility: visible; opacity: 1; transition: opacity 0.3s ease; }
        .explanation-scroll-content { flex-grow: 1; padding: 1.75rem; overflow-y: auto; scrollbar-width: thin; scrollbar-color: var(--gray-light) transparent; min-height: 0; } .explanation-scroll-content::-webkit-scrollbar { width: 8px; } .explanation-scroll-content::-webkit-scrollbar-track { background: transparent; } .explanation-scroll-content::-webkit-scrollbar-thumb { background-color: var(--gray-light); border-radius: 4px; border: 2px solid var(--call-panel-bg); }
        #explanation-display { line-height: 1.7; font-size: 0.95rem; } #explanation-display .step { margin-bottom: 1.5rem; padding: 1.25rem; border-radius: 10px; background-color: #ffffff; border: 1px solid #edf2f7; box-shadow: var(--shadow-sm); transition: box-shadow 0.2s ease, border-color 0.2s ease; } #explanation-display .step:hover { box-shadow: var(--shadow-md); border-color: #dbe4f0; } #explanation-display .step:last-child { margin-bottom: 0; } #explanation-display h3 { color: var(--secondary); margin-top: 0; margin-bottom: 0.8rem; font-size: 1.15rem; padding-bottom: 0.4rem; border-bottom: 1px solid var(--gray-light); } #explanation-display code { background-color: rgba(var(--primary-rgb), 0.07); padding: 0.2em 0.45em; border-radius: 4px; font-size: 0.9em; color: #3f37c9; border: 1px solid rgba(var(--primary-rgb), 0.1); } #explanation-display pre { margin: 1rem 0; } #explanation-display pre code { display: block; background-color: #f0f2f5; color: #333; padding: 1rem; border-radius: 6px; font-size: 0.9rem; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; border: 1px solid #e2e8f0; box-shadow: inset 0 1px 2px rgba(0,0,0,0.05); } #explanation-display strong { color: var(--dark); font-weight: 600; } #explanation-display blockquote { border-left: 4px solid var(--info); padding-left: 1rem; margin: 1rem 0 1rem 0.25rem; color: #4a5568; font-style: normal; background-color: rgba(76, 201, 240, 0.06); border-radius: 0 6px 6px 0; } #explanation-display ul, #explanation-display ol { margin-left: 1.25rem; margin-bottom: 0.8rem; padding-left: 1rem; } #explanation-display li { margin-bottom: 0.6rem; }
        .explanation-controls { flex-shrink: 0; margin-top: auto; padding: 1rem 1.75rem; border-top: 1px solid var(--gray-light); text-align: center; background-color: #f8f9fa; display: flex; justify-content: space-between; gap: 1rem; } .explanation-controls .btn { flex: 1; }
        #chat-tab-content { display: flex; flex-direction: column; height: 100%; }
        .chat-messages { flex-grow: 1; padding: 1.25rem; overflow-y: auto; scrollbar-color: var(--gray-light) var(--call-panel-bg); min-height: 0; }
        .chat-messages::-webkit-scrollbar { width: 8px; } .chat-messages::-webkit-scrollbar-track { background: var(--call-panel-bg); } .chat-messages::-webkit-scrollbar-thumb { background-color: var(--gray-light); border-radius: 4px; border: 2px solid var(--call-panel-bg); }
        .chat-input-area { flex-shrink: 0; padding: 1rem 1.25rem; background-color: #f8f9fa; border-top: 1px solid var(--gray-light); display: flex; align-items: flex-end; gap: 0.75rem; }
        .chat-message { display: flex; gap: 0.75rem; max-width: 92%; align-items: flex-end; margin-bottom: 1.25rem; }
        .chat-message.user { margin-left: auto; flex-direction: row-reverse; } .message-avatar { width: var(--avatar-size); height: var(--avatar-size); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 500; font-size: 0.95rem; flex-shrink: 0; box-shadow: var(--shadow-sm); border: 2px solid var(--call-panel-bg); } .chat-message.user .message-avatar { background: var(--success); color: white; } .chat-message.model .message-avatar { background: var(--primary); color: white; } .message-bubble { padding: 0.8rem 1.2rem; border-radius: 16px; line-height: 1.6; word-wrap: break-word; box-shadow: var(--shadow-sm); position: relative; background-color: var(--white); color: var(--text-primary); border: 1px solid #eef2f7; transition: box-shadow 0.2s ease; } .message-bubble:hover { box-shadow: var(--shadow-md); } .chat-message.model .message-bubble { border-bottom-left-radius: 5px; background: linear-gradient(145deg, #ffffff, #f9faff); } .chat-message.user .message-bubble { background: var(--gradient-1); color: white; border: none; border-bottom-right-radius: 5px; } .message-bubble code { background-color: rgba(var(--primary-rgb), 0.07); padding: 0.15em 0.4em; border-radius: 4px; font-size: 0.9em; color: #3f37c9; border: 1px solid rgba(var(--primary-rgb), 0.1); } .chat-message.user .message-bubble code { background-color: rgba(255, 255, 255, 0.15); color: #e0e0ff; border: 1px solid rgba(255, 255, 255, 0.2); } .message-bubble pre { margin: 0.7rem 0; } .message-bubble pre code { display: block; background-color: #f0f2f5; color: #333; padding: 0.8rem; border-radius: 6px; font-size: 0.88rem; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; border: 1px solid #e2e8f0; box-shadow: inset 0 1px 2px rgba(0,0,0,0.05); } .chat-message.user .message-bubble pre code { background-color: rgba(0,0,0,0.3); color: #eee; border: 1px solid rgba(255,255,255,0.1); } .message-timestamp { font-size: 0.75rem; color: var(--text-muted); margin-top: 5px; display: block; text-align: left; opacity: 0.8; } .chat-message.user .message-timestamp { text-align: right; }
        .message-thinking-indicator { background: var(--white); display: flex; align-items: center; padding: 0.8rem 1.1rem; border-radius: 16px; box-shadow: var(--shadow-sm); border: 1px solid #eef2f7; width: fit-content; border-bottom-left-radius: 5px;} .typing-dot { width: 7px; height: 7px; background-color: var(--gray); border-radius: 50%; margin: 0 3px; display: inline-block; animation: typing 1.3s infinite ease-in-out; } .typing-dot:nth-child(2) { animation-delay: 0.2s; } .typing-dot:nth-child(3) { animation-delay: 0.4s; } @keyframes typing { 0%, 60%, 100% { transform: translateY(0); opacity: 0.5; } 30% { transform: translateY(-3px); opacity: 1; } }
        .chat-input { flex-grow: 1; padding: 0.8rem 1.1rem; border: 1px solid var(--gray-light); border-radius: 20px; font-size: 0.95rem; resize: none; max-height: 120px; overflow-y: auto; transition: border-color 0.2s ease, box-shadow 0.2s ease; line-height: 1.45; background-color: var(--white); } .chat-input:focus { outline: none; border-color: var(--primary); box-shadow: 0 0 0 3px rgba(var(--primary-rgb), 0.1); } .send-button { padding: 0 1.2rem; border-radius: 20px; font-weight: 600; font-size: 0.95rem; cursor: pointer; border: none; background: var(--gradient-1); color: white; transition: all 0.3s ease; flex-shrink: 0; height: 42px; display: flex; align-items: center; justify-content: center; box-shadow: var(--shadow-sm); } .send-button:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 5px 10px rgba(var(--primary-rgb), 0.2); } .send-button:active:not(:disabled) { transform: translateY(-1px); box-shadow: 0 3px 6px rgba(var(--primary-rgb), 0.15); } .send-button i { font-size: 1.1em; } .send-button .fa-spinner { margin: 0; }
        .chat-controls { flex-shrink: 0; padding: 0.5rem 1.25rem; font-size: 0.8rem; color: var(--text-muted); text-align: right; background-color: #f8f9fa; border-top: 1px solid var(--gray-light); } .chat-controls button { background:none; border:none; color: var(--text-muted); cursor:pointer; font-size: 0.95em; padding: 3px 6px; margin-left: 10px; transition: color 0.2s ease; } .chat-controls button:hover { color: var(--primary); }
        .loading-placeholder { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 2rem; text-align: center; font-style: italic; color: var(--text-muted); flex-grow: 1; min-height: 150px; } .loading-placeholder i { margin-bottom: 1rem; font-size: 2.2rem; color: var(--primary-light); animation: spin 1.5s linear infinite; } @keyframes spin { to { transform: rotate(360deg); } }
        .empty-state { text-align: center; padding: 2rem 1.5rem; color: var(--text-secondary); margin-top: 1rem; flex-grow: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 150px; } .empty-state i { font-size: 3rem; margin-bottom: 1.25rem; color: var(--gray-light); opacity: 0.7; } .empty-state h3 { font-size: 1.2rem; font-weight: 600; margin-bottom: 0.8rem; color: var(--dark); } .empty-state p { margin-bottom: 1.25rem; max-width: 450px; margin-left: auto; margin-right: auto; line-height: 1.55; }
        .btn { display: inline-flex; align-items: center; justify-content: center; padding: 0.7rem 1.4rem; border-radius: 8px; font-weight: 500; font-size: 0.9rem; text-decoration: none; transition: all 0.25s ease; cursor: pointer; border: none; gap: 0.5rem; line-height: 1.5; } .btn-primary { background: var(--gradient-1); color: white; box-shadow: var(--shadow-sm); } .btn-primary:hover:not(:disabled) { transform: translateY(-2px); box-shadow: var(--shadow-md); background: linear-gradient(135deg, var(--primary-light), var(--secondary)); } .btn-secondary { background-color: var(--white); color: var(--text-secondary); border: 1px solid var(--gray-light); box-shadow: var(--shadow-sm); } .btn-secondary:hover:not(:disabled) { background-color: #f8f9fa; color: var(--primary); border-color: var(--primary-light); } .btn-success { background: linear-gradient(135deg, var(--success), #05a381); color: white; box-shadow: var(--shadow-sm); } .btn-success:hover:not(:disabled) { transform: translateY(-2px); box-shadow: var(--shadow-md); background: linear-gradient(135deg, #0cd1a7, var(--success));} .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none !important; box-shadow: none !important; background: var(--gray); color: var(--white); border: none; } .btn i { font-size: 1em; }
        mjx-math[display="inline"] { color: var(--secondary); background-color: rgba(var(--primary-rgb), 0.1); padding: 0.15em 0.4em; border-radius: 4px; font-weight: 500; border: 1px solid rgba(var(--primary-rgb), 0.15); display: inline-block; line-height: 1; margin: 0 1px; vertical-align: baseline; box-shadow: 0 1px 2px rgba(0,0,0,0.05); } .chat-message.user .message-bubble mjx-math[display="inline"] { color: #cdeeff; background-color: rgba(255, 255, 255, 0.1); border-color: rgba(255, 255, 255, 0.15); box-shadow: none; } #explanation-display .step mjx-math[display="inline"] { background-color: rgba(var(--primary-rgb), 0.08); border-color: rgba(var(--primary-rgb), 0.12); }
        .mobile-menu-toggle { display: none; background: none; border: none; cursor: pointer; color: var(--dark); font-size: 1.6rem; margin-right: 1rem; padding: 0.5rem; z-index: 1060; transition: color 0.2s ease; } .mobile-menu-toggle:hover { color: var(--primary); }
        .sidebar-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.55); z-index: 1040; opacity: 0; transition: opacity 0.3s ease; backdrop-filter: blur(5px); } .sidebar-overlay.active { display: block; opacity: 1; }
        @keyframes fadeIn { 0% { opacity: 0; transform: translateY(8px); } 100% { opacity: 1; transform: translateY(0); } }
        @media (max-width: 1200px) { .interaction-panel { width: 340px; } .call-interface { padding: 1.2rem; gap: 1.2rem; } }
        @media (max-width: 992px) { :root { --sidebar-width: 80px; } .sidebar { width: 80px; } .sidebar-logo span, .sidebar-link span, .user-info, .sidebar-footer { display: none; } .sidebar-link i { margin-right: 0; font-size: 1.5rem; } .sidebar-logo i { margin-right: 0; } .sidebar-header, .sidebar-link { justify-content: center; } .user-profile { justify-content: center; padding: 0.75rem 0; } .user-avatar { margin-right: 0; } main { margin-left: 80px; width: calc(100% - 80px); } .call-interface { flex-direction: column; padding: 1rem; gap: 1rem; } .interaction-panel { width: 100%; height: 55vh; flex-grow: 0; flex-shrink: 1; order: 1; } .ai-presenter-area { height: 45vh; min-height: 280px; order: 2; flex-grow: 0; flex-shrink: 1; } #excalidraw-container { min-height: 200px; } }
        @media (max-width: 768px) { .main-header { padding: 0.8rem 1.2rem; } .header-content h1 { font-size: 1.3rem; } .interaction-tab { padding: 0.8rem 0.5rem; font-size: 0.9rem; } .chat-input { font-size: 0.9rem; padding: 0.7rem 1rem; } .send-button { height: 40px; padding: 0 1rem; } .btn { padding: 0.6rem 1.2rem; font-size: 0.85rem; } .interaction-panel { height: 60vh; } .ai-presenter-area { height: 40vh; } }
        @media (max-width: 576px) { :root { --sidebar-width: 0; } .sidebar { transform: translateX(-100%); z-index: 1050; width: 260px; } .sidebar.active { transform: translateX(0); } .sidebar.active .sidebar-logo span, .sidebar.active .sidebar-link span, .sidebar.active .user-info, .sidebar.active .sidebar-footer { display: block; } .sidebar.active .sidebar-link i { margin-right: 0.75rem; font-size: 1.25rem; } .sidebar.active .sidebar-header, .sidebar.active .sidebar-link { justify-content: flex-start; } .sidebar.active .user-profile { justify-content: flex-start; padding: 1rem; } .sidebar.active .user-avatar { margin-right: 0.75rem; } main { margin-left: 0; width: 100%; } .mobile-menu-toggle { display: block; } .main-header { padding: 0.7rem 1rem; } .header-content h1 { font-size: 1.15rem; } .call-interface { padding: 0.8rem; gap: 0.8rem; } .ai-presenter-area { min-height: 220px; } .message-bubble { padding: 0.7rem 1rem; } .chat-input { padding: 0.6rem 0.9rem; } .send-button { height: 38px; padding: 0 0.9rem; } }
        @media (prefers-color-scheme: dark) { :root { --white: #1a202c; --light: #2d3748; --dark: #e2e8f0; --gray-light: #4a5568; --text-primary: #e2e8f0; --text-secondary: #cbd5e0; --text-muted: #a0aec0; --dark-bg: #171923; --call-bg: #131720; --call-panel-bg: #1e2533; } body { background-color: var(--dark-bg); } main { background-color: var(--call-bg); } .main-header { background-color: var(--call-panel-bg); border-bottom-color: var(--gray-light); } .mobile-menu-toggle { color: var(--dark); } .ai-presenter-area, .interaction-panel { background-color: var(--call-panel-bg); box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3); border-color: var(--gray-light); } .ai-presenter-header { background-color: #242c3b; border-bottom-color: var(--gray-light); } #excalidraw-container { background-color: #ffffff; box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1); } #excalidraw-container .loading-placeholder { background-color: #1e2533; color: var(--text-muted); } #excalidraw-container .loading-placeholder i { color: var(--primary-light); } .interaction-tabs { background-color: #242c3b; border-bottom-color: var(--gray-light); } .interaction-tab { color: var(--text-secondary); } .interaction-tab:hover { color: var(--primary-light); background-color: rgba(72, 149, 239, 0.1); } .interaction-tab.active { color: var(--primary-light); border-bottom-color: var(--primary-light); background-color: var(--call-panel-bg); } .tab-content { background-color: var(--call-panel-bg); } .explanation-scroll-content { scrollbar-color: var(--gray) var(--call-panel-bg); } .explanation-scroll-content::-webkit-scrollbar-thumb { border-color: var(--call-panel-bg); } #explanation-display .step { background-color: #232a37; border-color: #3b4458; } #explanation-display pre code { background-color: #161a22; color: #d1d5db; border-color: #363d4b; } #explanation-display code { background-color: rgba(72, 149, 239, 0.15); color: var(--primary-light); border-color: rgba(72, 149, 239, 0.25); } #explanation-display strong { color: #f0f2f5; } #explanation-display blockquote { border-left-color: var(--primary); color: #a0b3d0; background-color: #242c3b; } .explanation-controls { background-color: #242c3b; border-top-color: var(--gray-light); } .chat-messages { scrollbar-color: var(--gray) var(--call-panel-bg); } .chat-messages::-webkit-scrollbar-track { background: var(--call-panel-bg); } .chat-messages::-webkit-scrollbar-thumb { border-color: var(--call-panel-bg); } .message-avatar { border-color: var(--call-panel-bg); } .message-bubble { background-color: var(--light); color: var(--text-primary); border-color: #3b4458; } .chat-message.user .message-bubble { background: var(--gradient-2); color: #1a202c; } .message-bubble code { background-color: rgba(255,255,255,0.08); color: var(--text-primary); border-color: rgba(255,255,255,0.12); } .chat-message.user .message-bubble code { background-color: rgba(0, 0, 0, 0.15); color: #2d3748; border-color: rgba(0,0,0,0.2); } .message-bubble pre code { background-color: #161a22; color: #d1d5db; border-color: #363d4b; } .chat-message.user .message-bubble pre code { background-color: rgba(0,0,0,0.25); color: #eee; } .message-thinking-indicator { background: var(--light); border-color: #3b4458;} .typing-dot { background-color: #8494a6; } .chat-input-area { background-color: #242c3b; border-top-color: var(--gray-light); } .chat-input { background-color: var(--dark-bg); color: var(--text-primary); border-color: var(--gray-light); } .chat-input::placeholder { color: var(--text-muted); } .chat-input:focus { box-shadow: 0 0 0 3px rgba(var(--primary-rgb), 0.2); } .chat-controls { background-color: #242c3b; border-top-color: var(--gray-light); } .chat-controls button { color: var(--text-muted); } .chat-controls button:hover { color: var(--primary-light); } .btn-secondary { background-color: var(--light); color: var(--text-secondary); border-color: var(--gray-light); } .btn-secondary:hover:not(:disabled) { background-color: #4a5568; color: var(--white); border-color: #6c757d; } .btn-success { background: linear-gradient(135deg, var(--success), #05a381); } .btn-success:hover:not(:disabled) { background: linear-gradient(135deg, #0cd1a7, var(--success));} .btn:disabled { background: #4a5568; color: #a0aec0; } .topic-loading-bar { background-color: var(--light); border-bottom-color: var(--gray-light); } .empty-state i { color: #4a5568; } .toast { background-color: var(--call-panel-bg); border-color: var(--gray-light); color: var(--text-primary); box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);} mjx-math[display="inline"] { color: var(--primary-light); background-color: rgba(72, 149, 239, 0.15); border-color: rgba(72, 149, 239, 0.25); box-shadow: 0 1px 2px rgba(0,0,0,0.1); } .chat-message.user .message-bubble mjx-math[display="inline"] { color: #eee; background-color: rgba(255, 255, 255, 0.08); border-color: rgba(255, 255, 255, 0.1); box-shadow: none; } #explanation-display .step mjx-math[display="inline"] { background-color: rgba(72, 149, 239, 0.15); border-color: rgba(72, 149, 239, 0.2); } }
        .toast { position: fixed; bottom: 20px; right: 20px; background-color: var(--white); color: var(--text-primary); border-radius: 8px; padding: 1rem 1.2rem; box-shadow: var(--shadow-lg); max-width: 320px; z-index: 1001; display: flex; align-items: center; transform: translateX(calc(100% + 30px)); opacity: 0; transition: all 0.4s cubic-bezier(0.68, -0.55, 0.27, 1.55); } .toast.show { transform: translateX(0); opacity: 1; } .toast.success { border-left: 4px solid var(--success); } .toast.success i { color: var(--success); } .toast.error { border-left: 4px solid var(--danger); } .toast.error i { color: var(--danger); } .toast.warning { border-left: 4px solid var(--warning); } .toast.warning i { color: var(--warning); } .toast.info { border-left: 4px solid var(--info); } .toast.info i { color: var(--info); } .toast i { margin-right: 0.8rem; font-size: 1.3rem; }
    </style>
</head>
<body>
    <div id="sidebar-overlay" class="sidebar-overlay"></div>

    <aside id="sidebar" class="sidebar">
        <div class="sidebar-header"> <a href="/" class="sidebar-logo"> <i class="fas fa-calculator"></i> <span>Justax</span> </a> </div>
        <ul class="sidebar-menu">
            <li class="sidebar-item"> <a href="/dashboard/dashboard.html" class="sidebar-link"> <i class="fas fa-th-large"></i> <span>Dashboard</span> </a> </li>
            <li class="sidebar-item"> <a href="/dashboard/procvicovani/main.html" class="sidebar-link active"> <i class="fas fa-book-open"></i> <span>Procvičování</span> </a> </li>
            <li class="sidebar-item"> <a href="/dashboard/pokrok.html" class="sidebar-link"> <i class="fas fa-chart-line"></i> <span>Pokrok</span> </a> </li>
            <li class="sidebar-item"> <a href="/dashboard/oceneni.html" class="sidebar-link"> <i class="fas fa-medal"></i> <span>Ocenění</span> </a> </li>
            <li class="sidebar-item"> <a href="/dashboard/materialy.html" class="sidebar-link"> <i class="fas fa-file-alt"></i> <span>Materiály</span> </a> </li>
            <li class="sidebar-item"> <a href="/dashboard/profile.html" class="sidebar-link"> <i class="fas fa-user-cog"></i> <span>Profil</span> </a> </li>
        </ul>
        <div class="user-profile"> <div class="user-avatar" id="user-avatar">?</div> <div class="user-info"> <div class="user-name" id="user-name">Načítání...</div> <div class="user-role">Student</div> </div> </div>
        <div class="sidebar-footer"> &copy; 2025 Justax </div>
    </aside>

    <main>
        <div class="main-header">
            <div class="header-content">
                <div style="display: flex; align-items: center; gap: 1rem;"> <button class="mobile-menu-toggle" id="mobile-menu-toggle"> <i class="fas fa-bars"></i> </button> <h1>Interaktivní výuka</h1> </div>
                <div class="header-actions"> <a href="/dashboard/procvicovani/main.html" class="btn btn-secondary"> <i class="fas fa-times"></i> Ukončit výuku </a> </div>
            </div>
        </div>
        <div class="topic-loading-bar"> <div id="current-topic-display"><span class="placeholder">Načítám data...</span></div> </div>
        <div class="call-interface" style="display: none;">
            <div class="ai-presenter-area">
                <div class="ai-presenter-header"> <div class="ai-avatar-placeholder"> <i class="fas fa-chalkboard-teacher"></i> </div> <div class="ai-presenter-info"> <h2>AI Tutor Justax</h2> <p id="ai-status-text">Čekání na téma...</p> </div> </div>
                <div id="excalidraw-container"> <div class="loading-placeholder"><i class="fas fa-spinner"></i><p>Načítám kreslící plochu...</p></div> </div>
            </div>
            <div class="interaction-panel">
                <div class="interaction-tabs"> <div class="interaction-tab active" data-tab="explanation-tab"> <i class="fas fa-graduation-cap"></i> Vysvětlení </div> <div class="interaction-tab" data-tab="chat-tab"> <i class="fas fa-comments"></i> Chat </div> </div>
                <div class="interaction-content-area">
                    <div id="explanation-tab-content" class="tab-content active"> <div class="explanation-scroll-content"> <div id="explanation-display"> <div class="empty-state"> <i class="fas fa-book-reader"></i> <h3>Výuka připravena</h3> <p>Počkejte na automatické načtení tématu.</p> </div> </div> </div> <div class="explanation-controls"> <button class="btn btn-primary btn-tooltip" id="next-step-btn" style="display: none;" title="Požádat AI o další krok vysvětlení"> <i class="fas fa-forward"></i> Další krok </button> <button class="btn btn-success btn-tooltip" id="mark-complete-btn" style="display: none;" title="Označit aktuální téma jako probrané"> <i class="fas fa-check-circle"></i> Téma dokončeno </button> </div> </div>
                    <div id="chat-tab-content" class="tab-content"> <section class="chat-area" style="display: flex; flex-direction: column; height: 100%;"> <div class="chat-messages" id="chat-messages"> </div> <div class="chat-input-area"> <textarea class="chat-input" id="chat-input" placeholder="Zeptej se na cokoli k tématu..." rows="1"></textarea> <button class="send-button" id="send-button" title="Odeslat zprávu"> <i class="fas fa-paper-plane"></i> </button> </div> <div class="chat-controls"> <button id="clear-chat-btn" class="btn-tooltip" title="Vymazat historii tohoto chatu"> <i class="fas fa-trash-alt"></i> Vymazat </button> | <button id="save-chat-btn" class="btn-tooltip" title="Uložit chat jako PDF"> <i class="fas fa-save"></i> Uložit PDF </button> </div> </section> </div>
                </div>
            </div>
        </div>
    </main>
    <div class="toast" id="toast"> <i class="fas fa-info-circle"></i> <div id="toast-message">Operace úspěšná.</div> </div>

    <script>
        // Wrap the entire script in a try-catch block for robust error handling
        try {
            // --- Constants & Configuration ---
            const SUPABASE_URL = 'https://qcimhjjwvsbgjsitmvuh.supabase.co';
            const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFjaW1oamp3dnNiZ2pzaXRtdnVoIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDI1ODA5MjYsImV4cCI6MjA1ODE1NjkyNn0.OimvRtbXuIUkaIwveOvqbMd_cmPN5yY3DbWCBYc9D10';
            // !!! SECURITY WARNING: Hardcoding API keys is insecure. Use environment variables or a backend proxy in production!
            const GEMINI_API_KEY = 'AIzaSyDQboM6qtC_O2sqqpaKZZffNf2zk6HrhEs';
            const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${GEMINI_API_KEY}`;
            const EXCALIDRAW_SCENE_REGEX = /EXCALIDRAW_SCENE:\s*```json\s*(\[[\s\S]*?\])\s*```\s*/g; // Regex to extract Excalidraw data

            // --- DOM Elements Cache ---
            const uiElements = {
                userAvatar: document.getElementById('user-avatar'),
                userName: document.getElementById('user-name'),
                mobileMenuToggle: document.getElementById('mobile-menu-toggle'),
                sidebar: document.getElementById('sidebar'),
                sidebarOverlay: document.getElementById('sidebar-overlay'),
                currentTopicDisplay: document.getElementById('current-topic-display'),
                explanationDisplay: document.getElementById('explanation-display'),
                explanationScrollContent: document.querySelector('.explanation-scroll-content'),
                excalidrawContainer: document.getElementById('excalidraw-container'),
                chatMessages: document.getElementById('chat-messages'),
                chatInput: document.getElementById('chat-input'),
                sendButton: document.getElementById('send-button'),
                saveChatBtn: document.getElementById('save-chat-btn'),
                clearChatBtn: document.getElementById('clear-chat-btn'),
                nextStepBtn: document.getElementById('next-step-btn'),
                markCompleteBtn: document.getElementById('mark-complete-btn'),
                toast: document.getElementById('toast'),
                toastMessage: document.getElementById('toast-message'),
                interactionTabs: document.querySelectorAll('.interaction-tab'),
                tabContents: document.querySelectorAll('.tab-content'),
                aiStatusText: document.getElementById('ai-status-text'),
                callInterface: document.querySelector('.call-interface')
            };

            // --- Global State ---
            let state = {
                supabase: null,
                currentUser: null,
                currentProfile: null,
                currentTopic: null, // { activity_id, plan_id, name, description, user_id, topic_id }
                currentPlanId: null,
                currentSessionId: null, // Unique ID for the current learning session
                geminiChatContext: [], // History for Gemini API calls
                excalidrawAPI: null, // Excalidraw API instance
                excalidrawElements: [], // Current elements on the Excalidraw canvas
                excalidrawRoot: null, // React root for Excalidraw
                geminiIsThinking: false, // Flag to prevent concurrent requests
                thinkingIndicatorId: null, // ID of the "..." thinking bubble
                topicLoadInProgress: false, // Flag to prevent concurrent topic loads
                lastExplanationTimestamp: 0, // Timestamp of the last explanation step
                activeInteractionTab: 'explanation-tab' // Currently active tab ('explanation-tab' or 'chat-tab')
            };

            // --- Utility Functions ---
            const sanitizeHTML = (str) => {
                const temp = document.createElement('div');
                temp.textContent = str || '';
                return temp.innerHTML;
            };
            const getInitials = (profile, email) => {
                if (!profile && !email) return '?';
                let initials = '';
                if (profile?.first_name) initials += profile.first_name[0];
                if (profile?.last_name) initials += profile.last_name[0];
                if (initials) return initials.toUpperCase();
                if (profile?.username) return profile.username[0].toUpperCase();
                if (email) return email[0].toUpperCase();
                return 'U';
            };
            const showToast = (message, type = 'info', duration = 4000) => {
                if (!uiElements.toast || !uiElements.toastMessage) return;
                console.log(`Toast (${type}): ${message}`);
                uiElements.toastMessage.textContent = message;
                const icon = uiElements.toast.querySelector('i');
                uiElements.toast.className = 'toast ' + type;
                icon.className = `fas ${type === 'success' ? 'fa-check-circle' : type === 'error' ? 'fa-exclamation-circle' : type === 'warning' ? 'fa-exclamation-triangle' : 'fa-info-circle'}`;
                // Trigger reflow to restart animation
                uiElements.toast.style.transition = 'none';
                uiElements.toast.style.transform = 'translateX(calc(100% + 30px))';
                uiElements.toast.style.opacity = '0';
                void uiElements.toast.offsetWidth; // Trigger reflow
                uiElements.toast.style.transition = 'all 0.4s cubic-bezier(0.68, -0.55, 0.27, 1.55)';

                uiElements.toast.classList.add('show');
                setTimeout(() => uiElements.toast.classList.remove('show'), duration);
            };
            const renderMarkdown = (element, markdownText) => {
                if (!element) return;
                // console.log("Rendering Markdown in element:", element); // Keep for debug if needed
                try {
                    // Sanitize *before* parsing to prevent potential XSS in Markdown
                    // Note: marked() itself escapes HTML by default unless { sanitize: false } is used.
                    // For extra safety or specific needs, a dedicated sanitizer like DOMPurify could be added here.
                    element.innerHTML = marked.parse(markdownText || '');
                } catch (e) {
                    console.error("Markdown rendering error:", e);
                    element.innerHTML = `<p style="color:red;">Chyba renderování Markdownu.</p><pre>${sanitizeHTML(markdownText)}</pre>`;
                }
            };
            const autoResizeTextarea = () => {
                if (!uiElements.chatInput) return;
                uiElements.chatInput.style.height = 'auto'; // Reset height to calculate scrollHeight correctly
                const scrollHeight = uiElements.chatInput.scrollHeight;
                const maxHeight = 150; // Max height in pixels
                uiElements.chatInput.style.height = `${Math.min(scrollHeight, maxHeight)}px`;
                uiElements.chatInput.style.overflowY = scrollHeight > maxHeight ? 'scroll' : 'hidden';
            };
            const generateSessionId = () => `session_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;
            const formatTimestamp = (date = new Date()) => date.toLocaleTimeString('cs-CZ', { hour: '2-digit', minute: '2-digit' });
            const updateAIStatus = (text) => {
                if (uiElements.aiStatusText) uiElements.aiStatusText.textContent = text;
            };

            // --- Initialization Functions ---
            const initializeSupabase = () => {
                console.log("Initializing Supabase...");
                try {
                    if (typeof window.supabase === 'undefined' || typeof window.supabase.createClient !== 'function') {
                        throw new Error("Supabase library not loaded or invalid.");
                    }
                    state.supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                    if (!state.supabase) {
                        throw new Error("Supabase client creation failed.");
                    }
                    console.log("Supabase client initialized.");
                    return true;
                } catch (error) {
                    console.error("Supabase initialization failed:", error);
                    showToast("Chyba připojení k databázi. Obnovte stránku.", "error", 10000);
                    return false;
                }
            };
            const initializeUI = () => {
                console.log("Initializing UI elements and Excalidraw...");
                if (!initializeExcalidraw()) {
                    showToast("Kritická chyba: Nepodařilo se inicializovat kreslící plochu!", "error", 10000);
                    if (uiElements.callInterface) uiElements.callInterface.style.display = 'none';
                    if (uiElements.currentTopicDisplay) uiElements.currentTopicDisplay.innerHTML = '<span class="placeholder" style="color:var(--danger);">Chyba inicializace Excalidraw</span>';
                    return false;
                }
                const lastTab = sessionStorage.getItem('activeVyukaTab');
                switchInteractionTab(lastTab || 'explanation-tab'); // Restore last tab or default to explanation
                setupEventListeners();
                initTooltips();
                manageUIState('initial'); // Set initial UI state
                manageButtonStates(); // Set initial button states
                return true;
            };
            const initializeApp = async () => {
                console.log("DOM Loaded. Initializing Justax AI Tutor (Excalidraw Mode)...");
                if (!initializeSupabase()) return;
                if (!initializeUI()) return;

                console.log("Loading user profile...");
                manageUIState('loadingUser'); // Indicate user loading
                await loadUserProfile();

                if (state.currentUser) {
                    console.log("User logged in, loading topic...");
                    await loadNextUncompletedTopic();
                } else {
                    handleLoggedOutUser();
                }
            };

            // --- UI State Management ---
            const manageUIState = (mode) => {
                console.log("Managing UI State:", mode);
                const isUserInteractionPossible = ['learning', 'chatting'].includes(mode);
                const isTopicLoading = ['loadingUser', 'loadingTopic', 'requestingExplanation'].includes(mode);
                const showCallInterface = !!state.currentTopic || isTopicLoading; // Show if topic loaded or loading

                if (uiElements.callInterface) {
                    uiElements.callInterface.style.display = showCallInterface ? 'flex' : 'none';
                     console.log(showCallInterface ? "Showing call interface" : "Hiding call interface", " based on mode:", mode);
                }

                // Update explanation display based on state
                if (uiElements.explanationDisplay) {
                    let content = uiElements.explanationDisplay.innerHTML; // Default to keep current content
                    switch (mode) {
                        case 'initial':
                        case 'loadingUser':
                            content = "<div class='empty-state'><i class='fas fa-user-circle'></i><h3>Načítám profil...</h3><p>Prosím čekejte.</p></div>";
                            break;
                        case 'loggedOut':
                            content = "<div class='empty-state'><i class='fas fa-sign-in-alt'></i><h3>Nejste přihlášeni</h3><p>Přihlaste se prosím pro zahájení výuky.</p></div>";
                            break;
                        case 'noPlan':
                            content = "<div class='empty-state'><i class='fas fa-calendar-times'></i><h3>Žádný aktivní plán</h3><p>Nemáte aktivní studijní plán. Vytvořte si jej v sekci Procvičování.</p></div>";
                            break;
                        case 'planComplete':
                            content = "<div class='empty-state'><i class='fas fa-check-circle'></i><h3>Plán dokončen</h3><p>Gratulujeme, všechna témata jsou probrána!</p></div>";
                            break;
                        case 'error':
                             // Keep existing content if error occurs during operation, otherwise show generic error
                             if (!uiElements.explanationDisplay.querySelector('.step')) {
                                 content = "<div class='empty-state'><i class='fas fa-exclamation-triangle'></i><h3>Chyba</h3><p>Při načítání dat došlo k chybě.</p></div>";
                             }
                            break;
                        case 'loadingTopic':
                            content = "<div class='loading-placeholder'><i class='fas fa-spinner fa-spin'></i><p>Načítám téma...</p></div>";
                            break;
                        case 'requestingExplanation':
                             // Only show loading if explanation is empty
                             if (!uiElements.explanationDisplay.querySelector('.step')) {
                                content = "<div class='loading-placeholder'><i class='fas fa-spinner fa-spin'></i><p>Požaduji úvodní vysvětlení...</p></div>";
                             }
                            break;
                        case 'learning':
                        case 'chatting':
                             // Keep existing content or show empty if nothing is there yet
                             if (!uiElements.explanationDisplay.hasChildNodes() || uiElements.explanationDisplay.querySelector('.empty-state, .loading-placeholder')) {
                                 content = "<div class='empty-state'><i class='fas fa-hourglass-half'></i><h3>Čekám na vysvětlení...</h3><p>AI Tutor brzy začne.</p></div>";
                             }
                             break;
                    }
                    uiElements.explanationDisplay.innerHTML = content;
                }

                // Update Excalidraw view mode based on state
                if (state.excalidrawAPI?.updateScene) {
                    try {
                        state.excalidrawAPI.updateScene({ appState: { viewModeEnabled: !isUserInteractionPossible } });
                        console.log(`Excalidraw view mode set to: ${!isUserInteractionPossible}`);
                    } catch (e) {
                        console.error("Error setting Excalidraw view mode:", e);
                    }
                }
                manageButtonStates(); // Always update button states
            };

            const manageButtonStates = () => {
                const canInteract = !!state.currentTopic && !state.geminiIsThinking && !state.topicLoadInProgress;
                const isLearningState = state.currentTopic && !state.topicLoadInProgress;

                if (uiElements.sendButton) {
                    uiElements.sendButton.disabled = !canInteract;
                    uiElements.sendButton.innerHTML = state.geminiIsThinking ? '<i class="fas fa-spinner fa-spin"></i>' : '<i class="fas fa-paper-plane"></i>';
                }
                if (uiElements.nextStepBtn) {
                    uiElements.nextStepBtn.disabled = !canInteract;
                    uiElements.nextStepBtn.style.display = isLearningState ? 'inline-flex' : 'none';
                }
                if (uiElements.markCompleteBtn) {
                    uiElements.markCompleteBtn.disabled = !canInteract;
                    uiElements.markCompleteBtn.style.display = isLearningState ? 'inline-flex' : 'none';
                }
                if (uiElements.chatInput) {
                    uiElements.chatInput.disabled = !canInteract;
                }
            };

             // --- Excalidraw Functions ---
             const initializeExcalidraw = () => {
                 console.log("Initializing Excalidraw...");
                 const container = uiElements.excalidrawContainer;
                 if (!container) {
                     console.error("Excalidraw container not found!");
                     return false;
                 }
                 if (typeof React === 'undefined' || typeof ReactDOM === 'undefined' || typeof ExcalidrawLib === 'undefined') {
                     console.error("React, ReactDOM, or Excalidraw library not loaded!");
                     container.innerHTML = '<p style="color:red; padding: 1rem;">Chyba: Potřebné knihovny (React, Excalidraw) nebyly načteny.</p>';
                     return false;
                 }
                 try {
                     // Add initial loading placeholder
                     container.innerHTML = '<div class="loading-placeholder"><i class="fas fa-spinner"></i><p>Načítám kreslící plochu...</p></div>';

                     if (state.excalidrawRoot) {
                         console.warn("Excalidraw already initialized, unmounting first.");
                         state.excalidrawRoot.unmount();
                         state.excalidrawRoot = null;
                         state.excalidrawAPI = null;
                     }

                     state.excalidrawRoot = ReactDOM.createRoot(container);
                     const initialData = {
                         appState: {
                             viewBackgroundColor: "#ffffff",
                             currentItemFontFamily: 1, // Virgil
                             currentItemFontSize: 20,
                             theme: 'light',
                             viewModeEnabled: true // Start in view mode
                         },
                         elements: [],
                         scrollToContent: true
                     };

                     state.excalidrawRoot.render(
                         React.createElement(ExcalidrawLib.Excalidraw, {
                             initialData: initialData,
                             excalidrawAPI: (api) => {
                                 if (!state.excalidrawAPI) { // Ensure API is set only once
                                    state.excalidrawAPI = api;
                                    console.log("Excalidraw API ready.");
                                    // Remove placeholder once API is ready
                                    const placeholder = container.querySelector('.loading-placeholder');
                                    if (placeholder) placeholder.remove();
                                     // Clear any potential leftover elements (safer)
                                     api.updateScene({ elements: [] });
                                 }
                             },
                             UIOptions: {
                                 canvasActions: {
                                     saveToActiveFile: false, // Disable default save actions
                                     loadScene: false,
                                     export: { // Keep export if needed for debugging
                                        saveFileToDisk: true,
                                     },
                                     clearCanvas: false, // Disable clear canvas button
                                 }
                             },
                             viewModeEnabled: true, // Start in view mode
                             zenModeEnabled: false,
                             gridModeEnabled: false,
                             onChange: (elements, appState) => {
                                 // Only update state.excalidrawElements if necessary
                                 // This can be heavy if called too often without need
                                 // state.excalidrawElements = elements;
                                // console.log("Excalidraw onChange triggered"); // Optional debug log
                             }
                         })
                     );
                     console.log("Excalidraw component mount initiated.");
                     return true;
                 } catch (error) {
                     console.error("Error mounting Excalidraw:", error);
                     container.innerHTML = `<div class="loading-placeholder" style="color:var(--danger);"><i class="fas fa-exclamation-triangle"></i><p>Chyba Excalidraw:<br>${error.message}</p></div>`;
                     return false;
                 }
             };

            /** Safely updates the Excalidraw scene, including error catching and ensuring view mode is off. */
            const updateExcalidrawScene = (elements) => {
                if (!state.excalidrawAPI) {
                    console.warn("Excalidraw API not available for scene update.");
                    showToast("Chyba: Kreslící plocha není připravena.", "error");
                    return;
                }
                if (!Array.isArray(elements)) {
                    console.warn("Attempted to update scene with non-array elements:", elements);
                    elements = []; // Default to empty array if data is invalid
                }

                console.log(`Updating Excalidraw scene with ${elements.length} elements.`);
                if (elements.length > 0) {
                    // Log structure of first few elements for debugging
                    console.log("First few elements data (structure check):", elements.slice(0, 2).map(el => ({ type: el?.type, id: el?.id, text: el?.text?.substring(0,20) })));
                }

                const placeholder = uiElements.excalidrawContainer?.querySelector('.loading-placeholder');
                if (placeholder) placeholder.style.display = 'none';

                try {
                    // --- *** KEY FIX: Explicitly set viewModeEnabled to false *** ---
                    state.excalidrawAPI.updateScene({
                        elements: elements,
                        appState: { viewModeEnabled: false } // Ensure interaction is possible
                    });
                    // ----------------------------------------------------------------

                    state.excalidrawElements = elements; // Update local cache

                    // Scroll to content after update, slight delay might help rendering
                    setTimeout(() => {
                        if (state.excalidrawAPI?.scrollToContent) {
                            const currentElements = state.excalidrawAPI.getSceneElements();
                            if (currentElements?.length > 0) {
                                console.log("Attempting to scroll to content...");
                                try {
                                    state.excalidrawAPI.scrollToContent(currentElements, { fitToContent: true, duration: 300 });
                                } catch (scrollError) {
                                    console.warn("Error during scrollToContent:", scrollError);
                                }
                            } else {
                                console.log("No elements to scroll to after update.");
                            }
                        } else {
                            console.warn("scrollToContent function not available on Excalidraw API.");
                        }
                    }, 250); // Increased delay slightly

                } catch (error) {
                    console.error("!!! Error during ExcalidrawLib.updateScene call:", error);
                    showToast("Chyba při vykreslování na plochu Excalidraw.", "error");
                    console.error("Data that caused the rendering error:", JSON.stringify(elements)); // Log problematic data
                }
            };


            // --- User Profile & Auth ---
            const loadUserProfile = async () => {
                if (!state.supabase) {
                    console.error("Supabase not initialized in loadUserProfile.");
                    return;
                }
                try {
                    const { data: { user }, error: userError } = await state.supabase.auth.getUser();
                    if (userError) throw userError;

                    if (user) {
                        state.currentUser = user;
                        const { data: profile, error: profileError } = await state.supabase
                            .from('profiles')
                            .select('*')
                            .eq('id', user.id)
                            .single();
                        // PGRST116: No rows found, which is not necessarily an error here
                        if (profileError && profileError.code !== 'PGRST116') throw profileError;
                        state.currentProfile = profile;
                        console.log("User profile loaded:", state.currentProfile);
                    } else {
                        state.currentUser = null;
                        state.currentProfile = null;
                        console.log("No user logged in.");
                    }
                } catch (error) {
                    console.error('Error loading user profile:', error);
                    state.currentUser = null;
                    state.currentProfile = null;
                    showToast("Nepodařilo se načíst uživatelský profil.", "error");
                } finally {
                    updateUserInfoUI(); // Update UI regardless of success or failure
                }
            };
            const updateUserInfoUI = () => {
                if (uiElements.userName && uiElements.userAvatar) {
                    if (state.currentProfile || state.currentUser) {
                        const email = state.currentUser?.email;
                        const initials = getInitials(state.currentProfile, email);
                        const displayName = `${state.currentProfile?.first_name || ''} ${state.currentProfile?.last_name || ''}`.trim() || state.currentProfile?.username || email?.split('@')[0] || 'Uživatel';
                        uiElements.userName.textContent = displayName;
                        if (state.currentProfile?.avatar_url) {
                            uiElements.userAvatar.innerHTML = `<img src="${state.currentProfile.avatar_url}" alt="${initials}">`;
                        } else {
                            uiElements.userAvatar.innerHTML = ''; // Clear previous img if any
                            uiElements.userAvatar.textContent = initials;
                        }
                    } else {
                        uiElements.userName.textContent = 'Nepřihlášen';
                        uiElements.userAvatar.innerHTML = '?';
                    }
                }
            };
            const handleLoggedOutUser = () => {
                console.warn("User not logged in.");
                updateAIStatus("Přihlaste se pro zahájení výuky.");
                if (uiElements.currentTopicDisplay) uiElements.currentTopicDisplay.innerHTML = '<span class="placeholder">Nejste přihlášeni</span>';
                showToast("Prosím, přihlaste se.", "warning");
                manageUIState('loggedOut');
            };

            // --- Event Listeners Setup ---
            const setupEventListeners = () => {
                console.log("Setting up event listeners...");
                // Mobile Menu Toggle
                if (uiElements.mobileMenuToggle && uiElements.sidebar && uiElements.sidebarOverlay) {
                    uiElements.mobileMenuToggle.addEventListener('click', (e) => {
                        e.stopPropagation();
                        uiElements.sidebar.classList.toggle('active');
                        uiElements.sidebarOverlay.classList.toggle('active');
                    });
                    uiElements.sidebarOverlay.addEventListener('click', () => {
                        uiElements.sidebar.classList.remove('active');
                        uiElements.sidebarOverlay.classList.remove('active');
                    });
                    document.querySelector('main')?.addEventListener('click', () => {
                        if (uiElements.sidebar?.classList.contains('active')) {
                            uiElements.sidebar.classList.remove('active');
                            uiElements.sidebarOverlay.classList.remove('active');
                        }
                    });
                } else { console.warn("Mobile menu elements not found."); }

                // Interaction Tabs
                if (uiElements.interactionTabs.length > 0 && uiElements.tabContents.length > 0) {
                    uiElements.interactionTabs.forEach(tab => {
                        tab.addEventListener('click', () => switchInteractionTab(tab.dataset.tab));
                    });
                } else { console.warn("Interaction tab elements not found."); }

                // Chat Input & Send
                if (uiElements.chatInput && uiElements.sendButton) {
                    uiElements.chatInput.addEventListener('input', autoResizeTextarea);
                    uiElements.chatInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter' && !e.shiftKey) {
                            e.preventDefault(); // Prevent newline
                            if (!state.geminiIsThinking) handleSendMessage();
                        }
                    });
                    uiElements.sendButton.addEventListener('click', () => {
                        if (!state.geminiIsThinking) handleSendMessage();
                    });
                } else { console.warn("Chat input/send elements not found."); }

                // Chat Controls
                if (uiElements.clearChatBtn) uiElements.clearChatBtn.addEventListener('click', confirmClearChat);
                if (uiElements.saveChatBtn) uiElements.saveChatBtn.addEventListener('click', saveChatToPDF);

                // Explanation Controls
                if (uiElements.nextStepBtn) uiElements.nextStepBtn.addEventListener('click', requestNextStep);
                if (uiElements.markCompleteBtn) uiElements.markCompleteBtn.addEventListener('click', handleMarkTopicComplete);

                // Window Resize for Sidebar
                window.addEventListener('resize', () => {
                    if (window.innerWidth > 992 && uiElements.sidebar?.classList.contains('active')) {
                        uiElements.sidebar.classList.remove('active');
                        uiElements.sidebarOverlay.classList.remove('active');
                    }
                });
            };
            const initTooltips = () => {
                try {
                    if (window.jQuery && window.jQuery.fn.tooltipster) {
                        window.jQuery('.btn-tooltip:not(.tooltipstered)').tooltipster({
                            theme: 'tooltipster-shadow', // Or your preferred theme
                            animation: 'fade',
                            delay: 100,
                            side: 'top'
                        });
                    } else {
                        // Fallback or warning if jQuery/Tooltipster isn't loaded
                        console.warn("jQuery or Tooltipster not fully loaded for initTooltips.");
                    }
                } catch (e) {
                    console.error("Tooltipster initialization error:", e);
                }
            };


            // --- Topic Loading and Progress ---
            const loadNextUncompletedTopic = async () => {
                if (!state.currentUser || state.topicLoadInProgress || !state.supabase) {
                    console.log("Skipping topic load:", { loggedIn: !!state.currentUser, loading: state.topicLoadInProgress });
                    return;
                }
                state.topicLoadInProgress = true;
                state.currentTopic = null; // Clear previous topic first
                 // Clear previous state before loading new topic
                 if (uiElements.explanationDisplay) uiElements.explanationDisplay.innerHTML = '';
                 if (uiElements.chatMessages) uiElements.chatMessages.innerHTML = '';
                 updateExcalidrawScene([]);
                 state.geminiChatContext = [];
                 state.lastExplanationTimestamp = 0;


                if (uiElements.currentTopicDisplay) uiElements.currentTopicDisplay.innerHTML = '<span class="placeholder"><i class="fas fa-spinner fa-spin"></i> Hledám další téma...</span>';
                updateAIStatus('Hledám téma...');
                manageUIState('loadingTopic');

                try {
                    // 1. Find the active study plan for the user
                    const { data: activePlans, error: planError } = await state.supabase
                        .from('study_plans')
                        .select('id')
                        .eq('user_id', state.currentUser.id)
                        .eq('status', 'active')
                        .order('created_at', { ascending: false })
                        .limit(1);

                    if (planError) throw planError;

                    if (!activePlans || activePlans.length === 0) {
                        console.log("No active study plan found.");
                        if (uiElements.currentTopicDisplay) uiElements.currentTopicDisplay.innerHTML = '<span class="placeholder">Žádný aktivní studijní plán</span>';
                        showToast("Nemáte aktivní studijní plán.", "warning");
                        updateAIStatus("Nemáte aktivní plán.");
                        manageUIState('noPlan');
                        return; // Exit early if no plan
                    }
                    state.currentPlanId = activePlans[0].id;
                    console.log("Active plan ID:", state.currentPlanId);

                    // 2. Find the next uncompleted activity in that plan
                    const { data: nextActivities, error: activityError } = await state.supabase
                        .from('plan_activities')
                        .select('id, title, description, day_of_week, time_slot, topic_id, completed')
                        .eq('plan_id', state.currentPlanId)
                        .eq('completed', false)
                        .order('day_of_week', { ascending: true }) // Order matters for finding the *next* one
                        .order('time_slot', { ascending: true })
                        .limit(1);

                    if (activityError) throw activityError;

                    if (nextActivities && nextActivities.length > 0) {
                        const nextActivity = nextActivities[0];
                        console.log("Next activity found:", nextActivity);

                        // 3. Fetch topic details if topic_id exists
                        let topicName = nextActivity.title || 'Nespecifikované téma';
                        let topicDescription = nextActivity.description || '';
                        if (nextActivity.topic_id) {
                            try {
                                const { data: topicData, error: topicError } = await state.supabase
                                    .from('exam_topics')
                                    .select('name, description')
                                    .eq('id', nextActivity.topic_id)
                                    .single();

                                if (topicError && topicError.code !== 'PGRST116') {
                                    console.warn(`Could not fetch topic details for ID ${nextActivity.topic_id}:`, topicError);
                                } else if (topicData) {
                                    topicName = topicData.name || topicName;
                                    topicDescription = topicData.description || topicDescription;
                                }
                            } catch (topicFetchError) {
                                console.error("Error fetching topic details:", topicFetchError);
                                // Continue with activity title as topic name
                            }
                        }

                        // 4. Set the current topic state
                        state.currentTopic = {
                            activity_id: nextActivity.id,
                            plan_id: state.currentPlanId,
                            name: topicName,
                            description: topicDescription,
                            user_id: state.currentUser.id, // Added user_id here
                            topic_id: nextActivity.topic_id // Keep topic_id if available
                        };
                        console.log("Current topic set:", state.currentTopic);

                        if (uiElements.currentTopicDisplay) uiElements.currentTopicDisplay.innerHTML = `Aktuální téma: <strong>${sanitizeHTML(state.currentTopic.name)}</strong>`;

                        // 5. Start the learning session for this topic
                        await startLearningSession();

                    } else {
                        // No more uncompleted activities found
                        console.log("All activities completed for the active plan.");
                        if (uiElements.currentTopicDisplay) uiElements.currentTopicDisplay.innerHTML = '<span class="placeholder">Gratulujeme, plán dokončen!</span>';
                        showToast("Všechna témata v plánu jsou dokončena!", "success");
                        updateAIStatus("Plán dokončen.");
                        manageUIState('planComplete');
                    }

                } catch (error) {
                    console.error('Error loading next topic:', error);
                    if (uiElements.currentTopicDisplay) uiElements.currentTopicDisplay.innerHTML = '<span class="placeholder" style="color:var(--danger);">Chyba načítání tématu</span>';
                    showToast(`Nepodařilo se načíst další téma: ${error.message}`, "error");
                    updateAIStatus("Chyba načítání.");
                    manageUIState('error');
                } finally {
                    state.topicLoadInProgress = false;
                    manageButtonStates(); // Ensure buttons are updated after loading finishes or fails
                }
            };
            const handleMarkTopicComplete = async () => {
                if (!state.currentTopic || !state.currentTopic.activity_id || !state.supabase || state.topicLoadInProgress) {
                    console.warn("Cannot mark complete: Missing data or load in progress.");
                    return;
                }
                console.log(`Marking activity ${state.currentTopic.activity_id} as complete.`);
                state.topicLoadInProgress = true; // Prevent other actions during save
                manageButtonStates(); // Disable buttons
                if (uiElements.markCompleteBtn) uiElements.markCompleteBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Ukládám...';

                try {
                    const { error } = await state.supabase
                        .from('plan_activities')
                        .update({ completed: true, updated_at: new Date().toISOString() })
                        .eq('id', state.currentTopic.activity_id);

                    if (error) throw error;

                    showToast(`Téma "${state.currentTopic.name}" dokončeno.`, "success");
                    state.currentTopic = null; // Clear current topic

                    // Reset UI for next topic
                    if (uiElements.currentTopicDisplay) uiElements.currentTopicDisplay.innerHTML = '<span class="placeholder">Načítám další...</span>';
                    if (uiElements.explanationDisplay) uiElements.explanationDisplay.innerHTML = '';
                    if (uiElements.chatMessages) uiElements.chatMessages.innerHTML = '';
                    updateExcalidrawScene([]);
                    state.geminiChatContext = [];
                    state.lastExplanationTimestamp = 0;

                    await loadNextUncompletedTopic(); // Load the next one immediately

                } catch (error) {
                    console.error(`Error marking activity ${state.currentTopic?.activity_id} complete:`, error);
                    showToast("Chyba při označování tématu jako dokončeného.", "error");
                    state.topicLoadInProgress = false; // Re-enable actions on error
                    manageButtonStates(); // Re-enable buttons
                } finally {
                    // Reset button text even if loading next topic fails later
                    if (uiElements.markCompleteBtn) uiElements.markCompleteBtn.innerHTML = '<i class="fas fa-check-circle"></i> Téma dokončeno';
                    // topicLoadInProgress will be set to false within loadNextUncompletedTopic's finally block
                }
            };

            // --- Learning Session Management ---
            const startLearningSession = async () => {
                if (!state.currentTopic || !state.currentUser || !state.supabase) {
                    console.error("Cannot start session: Missing topic, user, or Supabase client.");
                    updateAIStatus('Chyba: Nelze zahájit výuku.');
                    manageUIState('error');
                    return;
                }

                console.log(`Starting session for: "${state.currentTopic.name}" (Activity ID: ${state.currentTopic.activity_id})`);
                state.currentSessionId = generateSessionId(); // Generate a unique ID for this session
                updateAIStatus(`Vysvětluje: ${state.currentTopic.name}`);
                manageUIState('requestingExplanation'); // Show loading state for explanation

                // Reset chat and explanation specific state
                if (uiElements.chatMessages) uiElements.chatMessages.innerHTML = '';
                state.geminiChatContext = [];
                state.lastExplanationTimestamp = 0;

                // Reset Excalidraw (already done in loadNext) but ensure view mode is off
                updateExcalidrawScene([]); // Clear scene
                if (state.excalidrawAPI?.updateScene) {
                    try {
                        state.excalidrawAPI.updateScene({ appState: { viewModeEnabled: false } });
                        console.log("Excalidraw interaction enabled for new topic session.");
                    } catch (apiError) {
                        console.error("Error enabling Excalidraw interaction via API:", apiError);
                    }
                } else { console.warn("Excalidraw API not ready to enable interaction at session start."); }


                // Request initial explanation from Gemini
                const initialPrompt = _buildInitialPrompt();
                await sendToGemini(initialPrompt, 'explanation');
            };
            const switchInteractionTab = (tabId) => {
                if (!tabId || !uiElements.interactionTabs || !uiElements.tabContents) return;
                uiElements.interactionTabs.forEach(tab => {
                    tab.classList.toggle('active', tab.dataset.tab === tabId);
                });
                uiElements.tabContents.forEach(content => {
                    content.classList.toggle('active', content.id === `${tabId}-content`);
                });
                state.activeInteractionTab = tabId;
                sessionStorage.setItem('activeVyukaTab', tabId); // Persist active tab
                console.log(`Switched to tab: ${tabId}`);
                // Scroll to bottom if switching to chat tab with existing messages
                if (tabId === 'chat-tab' && uiElements.chatMessages) {
                    uiElements.chatMessages.scrollTop = uiElements.chatMessages.scrollHeight;
                }
            };
            const requestNextStep = async () => {
                if (state.geminiIsThinking || !state.currentTopic) return;
                console.log("Requesting next step...");
                updateAIStatus('AI přemýšlí...'); // Update status immediately
                const prompt = `Pokračuj ve vysvětlování tématu "${state.currentTopic.name}". Naváž na předchozí krok. **DŮRAZNĚ POUŽIJ Excalidraw, zejména POKUD pokračuješ v řešení příkladu nebo vysvětluješ geometrický koncept, graf, apod.** Zobrazuj jednotlivé kroky výpočtů nebo konstrukce na tabuli. Nezapomeň na formát \`EXCALIDRAW_SCENE: \`\`\`json [ ... ] \`\`\`\` a na KRÁTKÝ A VÝSTIŽNÝ souhrn pro chat (CHAT_SUMMARY:).`;
                await sendToGemini(prompt, 'explanation');
            };

             // --- Chat Functionality ---
            const addChatMessage = async (message, sender, saveToDb = true, timestamp = new Date()) => {
                 if (!uiElements.chatMessages) return;
                 const messageId = `msg-${Date.now()}-${Math.random().toString(16).substring(2, 8)}`;
                 const avatarInitial = sender === 'user' ? getInitials(state.currentProfile, state.currentUser?.email) : 'AI';

                 const messageDiv = document.createElement('div');
                 messageDiv.className = `chat-message ${sender === 'gemini' ? 'model' : sender}`;
                 messageDiv.id = messageId;

                 const avatarDiv = document.createElement('div');
                 avatarDiv.className = 'message-avatar';
                 avatarDiv.textContent = avatarInitial;

                 const bubbleDiv = document.createElement('div');
                 bubbleDiv.className = 'message-bubble';
                 renderMarkdown(bubbleDiv, message); // Render Markdown content inside bubble

                 const timestampDiv = document.createElement('div');
                 timestampDiv.className = 'message-timestamp';
                 timestampDiv.textContent = formatTimestamp(timestamp);

                 messageDiv.appendChild(avatarDiv);
                 messageDiv.appendChild(bubbleDiv);
                 messageDiv.appendChild(timestampDiv); // Append timestamp outside bubble

                 uiElements.chatMessages.appendChild(messageDiv);

                 // Smooth scroll to the new message
                 messageDiv.scrollIntoView({ behavior: 'smooth', block: 'end' });


                 // --- Database Saving Logic ---
                 if (saveToDb && state.supabase && state.currentUser && state.currentTopic && state.currentSessionId) {
                     const dataToSave = {
                         user_id: state.currentUser.id, // Use ?.id for safety
                         session_id: state.currentSessionId,
                         topic_id: state.currentTopic.topic_id || null, // Use stored topic_id
                         topic_name: state.currentTopic.name || null,
                         role: sender === 'gemini' ? 'model' : 'user',
                         content: message // Store the raw message content
                     };

                     // Basic validation before sending to DB
                     if (!dataToSave.session_id || !dataToSave.role || !dataToSave.content) {
                         console.error("Supabase chat save error: Missing required fields.", dataToSave);
                         showToast("Chyba: Nelze uložit zprávu, chybí data.", "error");
                         return; // Prevent DB call with invalid data
                     }

                     console.log("Attempting to save chat message:", dataToSave);
                     try {
                         const { error } = await state.supabase.from('chat_history').insert(dataToSave);
                         if (error) {
                             console.error("Supabase chat save error:", error);
                             console.error("Data that caused error:", dataToSave);
                             showToast(`Chyba ukládání chatu do DB: ${error.message}`, 'error');
                         } else {
                             console.log("Chat message saved to DB.");
                         }
                     } catch (dbError) {
                         console.error("Exception during chat save:", dbError);
                         console.error("Data during exception:", dataToSave);
                         showToast(`Výjimka při ukládání chatu: ${dbError.message}`, 'error');
                     }
                 }
            };
            const updateGeminiThinkingState = (isThinking) => {
                state.geminiIsThinking = isThinking;
                manageButtonStates(); // Centralized button state management
                if (isThinking) {
                    addThinkingIndicator();
                } else {
                    removeThinkingIndicator();
                }
            };
            const addThinkingIndicator = () => {
                if (state.thinkingIndicatorId || !uiElements.chatMessages) return; // Prevent duplicates
                const indicatorDiv = document.createElement('div');
                indicatorDiv.className = 'chat-message model'; // Style as AI message
                state.thinkingIndicatorId = `thinking-${Date.now()}`;
                indicatorDiv.id = state.thinkingIndicatorId;
                indicatorDiv.innerHTML = `
                    <div class="message-avatar">AI</div>
                    <div class="message-thinking-indicator">
                        <span class="typing-dot"></span>
                        <span class="typing-dot"></span>
                        <span class="typing-dot"></span>
                    </div>`;
                uiElements.chatMessages.appendChild(indicatorDiv);
                // Scroll to the indicator
                indicatorDiv.scrollIntoView({ behavior: 'smooth', block: 'end' });
            };
            const removeThinkingIndicator = () => {
                if (state.thinkingIndicatorId) {
                    const indicator = document.getElementById(state.thinkingIndicatorId);
                    if (indicator) {
                        indicator.remove();
                    }
                    state.thinkingIndicatorId = null;
                }
            };
            const handleSendMessage = async () => {
                const messageText = uiElements.chatInput.value.trim();
                if (!messageText || state.geminiIsThinking || !state.currentTopic) {
                    return; // Ignore empty messages or if AI is busy
                }

                const userTimestamp = new Date();
                // Add user message to UI and DB immediately
                await addChatMessage(messageText, 'user', true, userTimestamp);

                // Add user message to Gemini context
                state.geminiChatContext.push({ role: "user", parts: [{ text: messageText }] });

                // Clear input and resize
                uiElements.chatInput.value = '';
                autoResizeTextarea();
                uiElements.chatInput.focus();

                // Update state and UI to show AI is thinking
                updateAIStatus('AI přemýšlí...');
                updateGeminiThinkingState(true); // This also calls manageButtonStates

                // Send message to Gemini for processing
                await sendToGemini(messageText, 'chat');
            };
            const confirmClearChat = () => {
                if (confirm("Opravdu chcete vymazat historii tohoto chatu a kresbu?\nTato akce je nevratná.")) {
                    clearCurrentChatSessionHistory();
                }
            };
             const clearCurrentChatSessionHistory = async () => {
                 // Clear UI elements first for immediate feedback
                 if (uiElements.chatMessages) uiElements.chatMessages.innerHTML = '';
                 state.geminiChatContext = []; // Clear context for Gemini
                 updateExcalidrawScene([]); // Clear Excalidraw canvas
                 showToast("Historie chatu a kresba vymazána.", "info");
                 console.log("Chat history and Excalidraw cleared for this session.");

                 // Attempt to delete from Database if connection and session ID are valid
                 if (state.supabase && state.currentUser && state.currentSessionId) {
                     try {
                         console.log(`Attempting to delete chat history from DB for session: ${state.currentSessionId} and user: ${state.currentUser.id}`);
                         const { data, error } = await state.supabase
                             .from('chat_history')
                             .delete()
                             .eq('user_id', state.currentUser.id)
                             .eq('session_id', state.currentSessionId); // Match both user and session

                         if (error) {
                             console.error("Error deleting chat history from DB:", error);
                             showToast("Chyba při mazání historie z databáze.", "error");
                         } else {
                             console.log("Chat history successfully deleted from DB. Response data:", data);
                             // Note: Delete might return data depending on Supabase version/settings, usually null or count.
                         }
                     } catch (dbError) {
                         console.error("Exception during DB chat history deletion:", dbError);
                         showToast("Nastala výjimka při mazání historie z DB.", "error");
                     }
                 } else {
                      console.warn("Skipping DB deletion: Supabase client, user, or session ID not available.");
                 }
             };
            const saveChatToPDF = async () => {
                if (!uiElements.chatMessages || uiElements.chatMessages.children.length === 0) {
                    showToast("Není co uložit.", "warning");
                    return;
                }
                if (typeof html2pdf === 'undefined') {
                    showToast("Chyba: Knihovna pro generování PDF není načtena.", "error");
                    console.error("html2pdf library is not available.");
                    return;
                }

                showToast("Generuji PDF...", "info", 3000); // Show progress

                const chatContainer = document.createElement('div');
                chatContainer.id = "pdf-export-content";
                chatContainer.style.padding = "20mm"; // Add padding for margins

                // Define styles directly within the HTML for html2pdf
                const pdfStyles = `
                <style>
                    body { font-family: 'Poppins', Arial, sans-serif; font-size: 10pt; line-height: 1.5; color: #333; }
                    .pdf-header { text-align: center; margin-bottom: 15px; border-bottom: 1px solid #ccc; padding-bottom: 10px; }
                    .pdf-header h1 { font-size: 16pt; margin: 0 0 5px 0; color: #3f37c9; }
                    .pdf-header p { font-size: 9pt; color: #6c757d; margin: 0; }
                    .chat-message { margin-bottom: 12px; max-width: 90%; page-break-inside: avoid; }
                    .chat-message.user { margin-left: 10%; }
                    .chat-message.model { margin-right: 10%; }
                    .message-bubble { padding: 9px 13px; border-radius: 12px; background-color: #f1f3f5; border: 1px solid #dee2e6; display: inline-block; max-width: 100%; word-wrap: break-word; text-align: left; }
                    .chat-message.user .message-bubble { background-color: #e6f7ff; border-color: #b3e0ff; } /* Lighter blue for user */
                    .chat-message.model .message-bubble { background-color: #f8f9fa; border-color: #e9ecef; } /* Light gray for model */
                    .message-timestamp { font-size: 8pt; color: #888; margin-top: 4px; display: block; }
                    .chat-message.user .message-timestamp { text-align: right; }
                    .chat-message.model .message-timestamp { text-align: left; }
                    code { font-family: 'Courier New', Courier, monospace; background-color: #e9ecef; padding: 1px 4px; border-radius: 3px; font-size: 0.9em; color: #c7254e; border: 1px solid #ced4da; }
                    pre { margin: 6px 0; page-break-inside: avoid; }
                    pre code { display: block; padding: 10px; background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; white-space: pre-wrap; word-wrap: break-word; font-size: 0.85em; color: #212529; }
                    mjx-math { display: inline-block; } /* Basic MathJax styling */
                </style>
                `;
                chatContainer.innerHTML = pdfStyles;

                // Add Header
                const headerDiv = document.createElement('div');
                headerDiv.className = 'pdf-header';
                headerDiv.innerHTML = `<h1>Záznam chatu - ${sanitizeHTML(state.currentTopic?.name || 'Neznámé téma')}</h1><p>Exportováno: ${new Date().toLocaleString('cs-CZ')}</p>`;
                chatContainer.appendChild(headerDiv);

                // Clone chat messages
                Array.from(uiElements.chatMessages.children).forEach(msgElement => {
                    if (msgElement.classList.contains('chat-message') && !msgElement.querySelector('.message-thinking-indicator')) { // Exclude thinking indicator
                        const clone = msgElement.cloneNode(true);
                        const avatar = clone.querySelector('.message-avatar');
                        if (avatar) avatar.remove(); // Remove avatar for PDF
                        chatContainer.appendChild(clone);
                    }
                });

                // Generate PDF
                const filename = `chat-justax-${state.currentTopic?.name?.replace(/[^a-z0-9]/gi, '_') || 'vyuka'}-${formatTimestamp().replace(/[:\s]/g, '')}.pdf`;
                const options = {
                    margin: 15, // mm
                    filename: filename,
                    image: { type: 'jpeg', quality: 0.95 },
                    html2canvas: { scale: 2, useCORS: true, logging: false, letterRendering: true },
                    jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' },
                    pagebreak: { mode: ['avoid-all', 'css', 'legacy'] } // More robust page breaking
                };

                try {
                    await html2pdf().set(options).from(chatContainer).save();
                    showToast("Chat uložen jako PDF!", "success");
                } catch (pdfError) {
                    console.error("Chyba exportu PDF:", pdfError);
                    showToast("Nepodařilo se exportovat chat do PDF.", "error");
                }
            };

            // --- Gemini Interaction & Excalidraw Processing ---
            /** Extracts Excalidraw JSON data from Gemini's response text. */
            const parseExcalidrawScene = (responseText) => {
                // console.log("Attempting to parse Excalidraw scene data..."); // Less verbose log
                EXCALIDRAW_SCENE_REGEX.lastIndex = 0; // Reset regex state
                const match = EXCALIDRAW_SCENE_REGEX.exec(responseText);
                let sceneData = null;
                let cleanedText = responseText;

                if (match && match[1]) {
                    console.log("Found EXCALIDRAW_SCENE block.");
                    try {
                        // Attempt to clean potential trailing commas before closing brackets/braces
                        let jsonString = match[1].trim().replace(/,\s*([}\]])/g, '$1');
                        sceneData = JSON.parse(jsonString);

                        if (!Array.isArray(sceneData)) {
                            console.warn("Parsed Excalidraw data is not an array:", sceneData);
                            sceneData = null; // Discard if not an array
                        } else {
                            console.log(`Successfully parsed ${sceneData.length} Excalidraw elements.`);
                            // Remove the matched block from the text
                            cleanedText = cleanedText.replace(match[0], '').trim();
                        }
                    } catch (e) {
                        console.error("Failed to parse Excalidraw JSON:", e, "\nJSON String (Attempted):", match[1]);
                        // Keep original text if parsing fails, discard scene data
                        cleanedText = responseText;
                        sceneData = null;
                        showToast("Chyba parsování dat pro kresbu od AI.", "warning");
                    }
                } else {
                    // console.log("No EXCALIDRAW_SCENE block found."); // Less verbose log
                }
                return { cleanedText, sceneData };
            };
             /** Validates Excalidraw elements, logging details about invalid ones. */
            const validateExcalidrawElements = (elements) => {
                 if (!Array.isArray(elements)) {
                     console.error("Validation failed: Input is not an array.");
                     return { isValid: false, invalidElementsDetails: [{ index: -1, reason: "Input is not an array", element: elements }] };
                 }
                 const invalidElementsDetails = [];
                 // Enhanced required props check
                 const requiredPropsByType = {
                     text: ['type', 'x', 'y', 'width', 'height', 'text', 'fontSize', 'fontFamily'],
                     line: ['type', 'x', 'y', 'width', 'height', 'points'],
                     arrow: ['type', 'x', 'y', 'width', 'height', 'points'],
                     rectangle: ['type', 'x', 'y', 'width', 'height'],
                     ellipse: ['type', 'x', 'y', 'width', 'height'],
                     // Add other types if used by Gemini
                 };
                 const numericProps = ['x', 'y', 'width', 'height', 'angle', 'strokeWidth', 'fontSize', 'opacity'];

                 elements.forEach((el, index) => {
                     let elementIssues = [];
                     if (typeof el !== 'object' || el === null) {
                         elementIssues.push("Element is not an object or is null.");
                     } else if (!el.type || typeof el.type !== 'string') {
                         elementIssues.push("Missing or invalid 'type' property.");
                     } else {
                         // Check required props for the specific type
                         const requiredProps = requiredPropsByType[el.type] || ['type', 'x', 'y', 'width', 'height']; // Default set
                         for (const prop of requiredProps) {
                             if (el[prop] === undefined || el[prop] === null) { // Check for null too
                                 elementIssues.push(`Missing or null required property: '${prop}'.`);
                             }
                         }
                         // Check numeric props
                         for (const prop of numericProps) {
                             if (el[prop] !== undefined && el[prop] !== null && typeof el[prop] !== 'number') {
                                 elementIssues.push(`Non-numeric value for property '${prop}': ${JSON.stringify(el[prop])}.`);
                             }
                         }
                         // Check width/height positivity
                         if (typeof el.width === 'number' && el.width < 0) elementIssues.push(`Negative width: ${el.width}.`);
                         if (typeof el.height === 'number' && el.height < 0) elementIssues.push(`Negative height: ${el.height}.`);
                         if (typeof el.opacity === 'number' && (el.opacity < 0 || el.opacity > 100)) elementIssues.push(`Invalid opacity: ${el.opacity}.`);

                         // Type-specific checks
                         if (el.type === 'text' && typeof el.text !== 'string') {
                             elementIssues.push("Invalid 'text' property (must be string).");
                         }
                         if (['line', 'arrow'].includes(el.type)) {
                             if (!Array.isArray(el.points) || el.points.length < 2) {
                                 elementIssues.push("Invalid 'points' array (must be array with at least 2 points).");
                             } else {
                                 const hasInvalidPoint = el.points.some(p => !Array.isArray(p) || p.length !== 2 || typeof p[0] !== 'number' || typeof p[1] !== 'number');
                                 if (hasInvalidPoint) {
                                     elementIssues.push("Invalid point format within 'points' array (each point must be [number, number]).");
                                 }
                             }
                         }
                     }

                     if (elementIssues.length > 0) {
                         invalidElementsDetails.push({ index, reasons: elementIssues, element: el });
                     }
                 });

                 const overallIsValid = invalidElementsDetails.length === 0;
                 if (!overallIsValid) {
                     console.error(`Excalidraw data validation failed. Found issues in ${invalidElementsDetails.length} element(s).`);
                     invalidElementsDetails.forEach(inv => {
                         console.error(`--> Invalid Element (Index ${inv.index}): Reasons: ${inv.reasons.join(', ')}`);
                         console.log("Problematic Element Data:"); console.dir(inv.element); // Use console.dir for better object inspection
                     });
                 } else {
                     console.log("Excalidraw data validation successful.");
                 }
                 return { isValid: overallIsValid, invalidElementsDetails };
             };
             /** Adds missing default properties and attempts to fix common issues in Excalidraw elements. */
            const addDefaultExcalidrawProps = (elements) => {
                 if (!Array.isArray(elements)) return elements; // Return as is if not an array
                 console.log("Patching Excalidraw elements with default properties...");
                 const defaultSeed = Math.floor(Math.random() * 2 ** 31); // Consistent seed for patching run

                 return elements.map((el, index) => {
                     // Skip if element is fundamentally invalid (not an object)
                     if (typeof el !== 'object' || el === null) {
                         console.warn(`Skipping patching for invalid element at index ${index}:`, el);
                         return el;
                     }

                     // Ensure basic spatial properties are numeric, default to 0 or positive values
                     el.x = (typeof el.x === 'number') ? el.x : 0;
                     el.y = (typeof el.y === 'number') ? el.y : 0;
                     el.width = (typeof el.width === 'number' && el.width >= 0) ? el.width : 10; // Ensure non-negative
                     el.height = (typeof el.height === 'number' && el.height >= 0) ? el.height : 10; // Ensure non-negative
                     el.angle = (typeof el.angle === 'number') ? el.angle : 0;

                     // Default visual properties
                     el.strokeColor = (typeof el.strokeColor === 'string') ? el.strokeColor : '#000000'; // Default to black
                     el.backgroundColor = el.backgroundColor ?? 'transparent'; // Common default
                     el.fillStyle = el.fillStyle ?? 'hachure'; // Excalidraw default
                     el.strokeWidth = (typeof el.strokeWidth === 'number') ? el.strokeWidth : 1;
                     el.strokeStyle = el.strokeStyle ?? 'solid';
                     el.roughness = (typeof el.roughness === 'number') ? el.roughness : 0; // Default to clean lines
                     el.opacity = (typeof el.opacity === 'number' && el.opacity >= 0 && el.opacity <= 100) ? el.opacity : 100;
                     el.strokeSharpness = el.strokeSharpness ?? (el.type === 'line' || el.type === 'arrow' || el.type === 'freedraw' ? 'round' : 'sharp');

                     // Default metadata and state properties
                     el.seed = (typeof el.seed === 'number') ? el.seed : defaultSeed;
                     el.version = el.version ?? 2; // Use a reasonable version number
                     el.versionNonce = el.versionNonce ?? Math.floor(Math.random() * 2 ** 31);
                     el.isDeleted = el.isDeleted ?? false;
                     el.groupIds = Array.isArray(el.groupIds) ? el.groupIds : [];
                     el.frameId = el.frameId ?? null;
                     el.boundElements = Array.isArray(el.boundElements) ? el.boundElements : null; // Keep null if not array
                     el.updated = el.updated ?? Date.now();
                     el.link = el.link ?? null;
                     el.locked = el.locked ?? false;

                     // Type-specific defaults
                     if (el.type === 'text') {
                         el.fontSize = (typeof el.fontSize === 'number' && el.fontSize > 0) ? el.fontSize : 20;
                         el.fontFamily = (typeof el.fontFamily === 'number') ? el.fontFamily : 1; // 1: Virgil, 2: Helvetica, 3: Cascadia
                         el.text = (typeof el.text === 'string') ? el.text : '(Chybějící text)';
                         el.textAlign = el.textAlign ?? 'left';
                         el.verticalAlign = el.verticalAlign ?? 'top';
                         el.baseline = el.baseline ?? 18; // Approximate baseline for default font size
                         el.containerId = el.containerId ?? null;
                         el.originalText = el.originalText ?? el.text;
                     } else if (['rectangle', 'ellipse', 'diamond'].includes(el.type)) {
                          el.roundness = el.roundness ?? null; // Usually null unless specified
                     } else if (['line', 'arrow', 'freedraw'].includes(el.type)) {
                         // Ensure points is a valid array of pairs of numbers
                         if (!Array.isArray(el.points) || el.points.length < (el.type === 'freedraw' ? 1: 2) || el.points.some(p => !Array.isArray(p) || p.length !== 2 || typeof p[0] !== 'number' || typeof p[1] !== 'number')) {
                             console.warn(`Invalid points data found for ${el.type} element (index ${index}), resetting to default:`, el.points);
                             el.points = (el.type === 'freedraw' ? [[0,0]] : [[0, 0], [el.width || 10, el.height || 10]]); // Default points based on size
                         }
                         el.lastCommittedPoint = el.lastCommittedPoint ?? null;
                         el.startBinding = el.startBinding ?? null;
                         el.endBinding = el.endBinding ?? null;
                         el.startArrowhead = el.startArrowhead ?? null;
                         el.endArrowhead = el.endArrowhead ?? (el.type === 'arrow' ? 'arrow' : null); // Default end arrowhead for arrows
                     }
                      // Add any other missing common properties if needed

                     return el;
                 });
            };
             /** Processes Gemini response, handles Excalidraw data, and updates UI. */
            const processGeminiResponse = (rawResponseText, targetArea, timestamp) => {
                 removeThinkingIndicator(); // Remove "..." indicator
                 let chatSummary = null;
                 const summaryRegex = /CHAT_SUMMARY:\s*([\s\S]*)/im; // Case-insensitive multiline match
                 const summaryMatch = rawResponseText.match(summaryRegex);
                 let textForProcessing = rawResponseText;

                 // Extract Chat Summary
                 if (summaryMatch && summaryMatch[1]) {
                     chatSummary = summaryMatch[1].trim();
                     // Remove the summary block from the main text
                     textForProcessing = rawResponseText.replace(summaryRegex, '').trim();
                     console.log("Extracted Chat Summary:", chatSummary);
                 }

                 // Parse Excalidraw Scene
                 let { cleanedText, sceneData } = parseExcalidrawScene(textForProcessing);
                 let sceneUpdateAttempted = false;
                 let sceneDataIsValid = false;

                 if (sceneData) {
                     sceneUpdateAttempted = true;
                     sceneData = addDefaultExcalidrawProps(sceneData); // Patch with defaults
                     const validationResult = validateExcalidrawElements(sceneData); // Validate *after* patching
                     sceneDataIsValid = validationResult.isValid;

                     if (!sceneDataIsValid) {
                         console.error("Excalidraw Validation Failed AFTER patching. See detailed log above.");
                         showToast("Chyba: AI vrátila data pro kresbu, která nelze zobrazit.", "error");
                         // Add an error message to chat instead of trying to render invalid data
                         addChatMessage("Omlouvám se, data pro kreslící plochu jsou nekompatibilní a nelze je zobrazit.", 'gemini', false, new Date());
                     } else {
                         console.log("Patched Scene Data appears valid. Attempting update...");
                         updateExcalidrawScene(sceneData); // Update the canvas
                     }
                 }

                 const textToDisplayInExplanation = cleanedText; // Use the text remaining after potential extraction
                 const textToDisplayInChat = chatSummary || (targetArea === 'chat' ? cleanedText : null); // Use summary or cleaned text for chat

                 // Update Explanation Tab
                 if (targetArea === 'explanation') {
                     console.log("Processing for EXPLANATION area.");
                     const placeholder = uiElements.explanationDisplay.querySelector('.loading-placeholder, .empty-state');
                     if (placeholder) placeholder.remove(); // Remove loading/empty state

                     const isFirstStep = !uiElements.explanationDisplay.querySelector('.step');
                     if (isFirstStep) uiElements.explanationDisplay.innerHTML = ''; // Clear if it's the very first step

                     if (textToDisplayInExplanation.trim()) {
                         const stepDiv = document.createElement('div');
                         stepDiv.className = 'step';
                         renderMarkdown(stepDiv, textToDisplayInExplanation); // Render the main explanation
                         uiElements.explanationDisplay.appendChild(stepDiv);
                         state.lastExplanationTimestamp = Date.now(); // Track last update

                         // Scroll to the new step
                         if (uiElements.explanationScrollContent) {
                            setTimeout(() => {
                                stepDiv.scrollIntoView({ behavior: "smooth", block: "end" });
                             }, 100); // Short delay to allow rendering
                         }
                     } else {
                         console.log("No main text content provided by AI for this explanation step.");
                          // Add a small note if only Excalidraw was updated
                          if (sceneUpdateAttempted && sceneDataIsValid) {
                                const noteDiv = document.createElement('div');
                                noteDiv.className = 'step';
                                noteDiv.innerHTML = '<p><i>(AI aktualizovala kreslící plochu.)</i></p>';
                                uiElements.explanationDisplay.appendChild(noteDiv);
                          }
                     }

                     // Add summary to chat if available and different from main text
                     if (chatSummary && chatSummary !== textToDisplayInExplanation.trim()) {
                         addChatMessage(chatSummary, 'gemini', true, timestamp);
                     } else if (!chatSummary && (textToDisplayInExplanation.trim() || (sceneUpdateAttempted && sceneDataIsValid))) {
                         // Add a generic chat message if no summary but content was added/drawn
                         addChatMessage(`AI pokračovala ve vysvětlení ${sceneUpdateAttempted && sceneDataIsValid ? 'a aktualizovala kresbu' : ''}. Celý text je v záložce Vysvětlení.`, 'gemini', false, timestamp);
                     }
                     manageUIState('learning'); // Update overall UI state

                 }
                 // Update Chat Tab (only if target was chat, or if there's a specific chat summary)
                 else if (targetArea === 'chat') {
                     console.log("Processing for CHAT area.");
                     if (textToDisplayInChat && textToDisplayInChat.trim()) {
                         addChatMessage(textToDisplayInChat, 'gemini', true, timestamp);
                     } else if (sceneUpdateAttempted && sceneDataIsValid) {
                         // If only Excalidraw was updated in response to a chat message
                         addChatMessage("(Aktualizoval(a) jsem kresbu podle tvého dotazu.)", 'gemini', false, timestamp);
                     } else {
                         // If AI returned nothing useful for chat
                         addChatMessage("(AI neposkytla textovou odpověď ani platnou kresbu)", 'gemini', false, timestamp);
                         console.warn("AI chat response was empty, no summary, and no valid scene data found.");
                     }
                     manageUIState('chatting'); // Update overall UI state
                 }

                 // Trigger MathJax typesetting after DOM updates
                 if (window.MathJax && typeof window.MathJax.typesetPromise === 'function') {
                      setTimeout(() => {
                         console.log("MathJax: Queuing typeset after Gemini response processing.");
                         window.MathJax.typesetPromise().then(() => {
                              console.log("MathJax: Typesetting complete after Gemini response.");
                         }).catch(err => {
                              console.error('MathJax typesetting error after Gemini:', err);
                         });
                      }, 150); // Delay slightly to ensure DOM is updated
                 }
            };


            /** Builds the prompt for the initial explanation step. */
            const _buildInitialPrompt = () => {
                let prompt = `Jako AI Tutor "Justax" začni vysvětlovat ZÁKLADY tématu "${state.currentTopic.name}" pro studenta 9. třídy ZŠ (přijímačky CERMAT).`;
                if (state.currentTopic.description) {
                    prompt += ` Popis tématu pro kontext: "${state.currentTopic.description}".`;
                }
                prompt += ` Buď podrobný, přátelský a postupuj krok za krokem. Toto je ÚPLNĚ PRVNÍ krok vysvětlení tohoto tématu. **POUŽIJ kreslící plochu (Excalidraw) k VIZUALIZACI základního konceptu NEBO k UKÁZCE jednoduchého PŘÍKLADU krok za krokem, pokud je to relevantní pro úvod.** Nenechávej tabuli prázdnou, pokud se nabízí vizuální vysvětlení nebo příklad (např. ukázka jednoduché rovnice, geometrický náčrtek, číselná osa). Pro vizualizaci můžeš na konec odpovědi přidat JSON data pro Excalidraw ve formátu \`EXCALIDRAW_SCENE: \`\`\`json [ ... ] \`\`\`\`. Ukonči odpověď KRÁTKÝM A VÝSTIŽNÝM souhrnem (max 1-2 věty, jako zápis do sešitu) pro zobrazení v chatu ve formátu: \`CHAT_SUMMARY: [Zde tvůj krátký souhrn]\`.`;
                return prompt;
            }

            /** Builds the complete prompt for the Gemini API call including system instructions and history. */
            const _buildGeminiPayloadContents = (userPromptText, targetArea) => {
                 // Base system instruction defining the AI's role and rules
                 const systemInstructionText = `Jsi AI Tutor "Justax", expert na matematiku pro 9. třídu ZŠ v ČR (přijímačky CERMAT). Vyučuješ téma: "${state.currentTopic.name}"${state.currentTopic.description ? ` (Popis: "${state.currentTopic.description}")` : ''}. Tvůj styl je PŘÁTELSKÝ, TRPĚLIVÝ a PODROBNÝ. Vysvětluj krok za krokem, používej PŘESNÉ matematické termíny a jednoduché příklady. Důsledně používej Markdown pro formátování textu a MathJax pro matematické vzorce (blokové vzorce: $$...$$, inline vzorce: $...$ nebo \\(...\\)). Odpovídej VŽDY ČESKY.

DŮLEŽITÉ POKYNY PRO TEBE:
1.  **KROK ZA KROKEM:** V záložce "Vysvětlení" se drž JEDNOHO logického kroku nebo konceptu na odpověď. Buď systematický a postupný. Nezahlcuj studenta příliš mnoha informacemi najednou.
2.  **INTERAKTIVITA:** Pravidelně pokládej studentovi KONTROLNÍ OTÁZKY nebo ho vyzývej k zamyšlení.
3.  **VIZUALIZACE S EXCALIDRAW (KLÍČOVÉ PRO PŘÍKLADY):**
    * **AKTIVNĚ a ČASTO POUŽÍVEJ EXCALIDRAW**, PŘEDEVŠÍM k **ŘEŠENÍ KONKRÉTNÍCH PŘÍKLADŮ KROK ZA KROKEM**. Je to tvůj hlavní nástroj pro názorné ukázky výpočtů a postupů. Nenechávej tabuli prázdnou, pokud vysvětluješ něco, co lze ukázat na příkladu!
    * Použij Excalidraw také pro geometrické náčrty, grafy, číselné osy, zápisy vzorců apod., POKUD to přímo souvisí s vysvětlovaným krokem.
    * **FORMÁT:** Na KONEC textové odpovědi přidej JSON data pro Excalidraw: \`EXCALIDRAW_SCENE: \`\`\`json [ { /* element 1 */ }, ... ] \`\`\`\`. JSON musí být VALIDNÍ.
    * **OBSAH KRESBY (DŮLEŽITÉ):**
        * **PŘÍKLADY:** Zapiš zadání a **JEDNOTLIVÉ KROKY ŘEŠENÍ** jasně a čitelně. Použij textové elementy. Šipkami můžeš naznačit návaznost kroků. Buď EXPLICITNÍ v zobrazování kroků.
        * **ČITELNOST:** Použij **ČERNOU** nebo **TMAVĚ MODROU** barvu pro hlavní text a výpočty (#000000 nebo #1E3A8A). Pro zvýraznění můžeš použít **TMAVĚ ČERVENOU** (#DC2626) nebo **TMAVĚ ZELENOU** (#16A34A), ale střídmě. Pozadí VŽDY NECH BÍLÉ (#ffffff).
        * **FONT:** Použij výchozí font (Virgil - fontFamily: 1) nebo čitelný Helvetica (fontFamily: 2). Velikost písma (fontSize) zvol přiměřenou (např. 20 nebo 28), aby byla dobře vidět.
        * **STRUKTURA:** Kresli PŘEHLEDNĚ. Nepřekrývej prvky. Nový krok řešení umísti pod předchozí nebo vedle něj s jasnou návazností (např. šipkou).
        * **JEDNODUCHOST:** Používej základní tvary (text, line, arrow, rectangle, ellipse). Parametr 'roughness' nastav na 0 pro čisté linie.
        * **AKTUALIZACE:** Pošli VŽDY KOMPLETNÍ scénu pro daný krok (včetně prvků z předchozích kroků, pokud mají zůstat viditelné). Pro smazání tabule pošli prázdné pole \`[]\`.
        * **TEXT V KRESBĚ:** Textové elementy ('type': 'text') jsou klíčové pro zápis kroků řešení. Použij \`\\n\` pro nový řádek v textu. Pro matematické symboly v textu použij standardní zápis (např. +, -, *, /, =, <, >, ^, sqrt()).
        * **PŘÍKLAD KROKU ŘEŠENÍ ROVNICE:** \`{ "type": "text", "x": 20, "y": 100, "width": 300, "height": 60, "text": "2. Odečteme 5 od obou stran:\\n   2x + 5 - 5 = 11 - 5\\n   2x = 6", "fontSize": 20, "fontFamily": 1, "strokeColor": "#000000", "textAlign": "left", "roughness": 0 }\`
4.  **DÉLKA ODPOVĚDI:** Vysvětlení může být delší, ale členěné. Chatové odpovědi stručné.
5.  **VÝSTUP DO CHATU (SHRNUTÍ):** POKUD generuješ delší odpověď pro "Vysvětlení", na ÚPLNÝ konec celé odpovědi (i za případný EXCALIDRAW_SCENE blok) PŘIDEJ **KRÁTKÝ A VÝSTIŽNÝ** souhrn (max 1-2 věty, jako zápis do sešitu) pro zobrazení v chatu: \`CHAT_SUMMARY: [Zde tvůj krátký souhrn]\`.`;

                 // Filter relevant history - keep only user and model turns
                 const historyForApi = state.geminiChatContext.filter(item => item.role === 'user' || item.role === 'model');

                 // The current user prompt
                 const currentRequestContent = { role: "user", parts: [{ text: userPromptText }] };

                 // Construct the final payload for the API
                 const contentsPayload = [
                     // 1. System Instruction (as user role, common practice)
                     { role: "user", parts: [{ text: systemInstructionText }] },
                     // 2. Priming model response (to acknowledge instructions)
                     { role: "model", parts: [{ text: "Rozumím. Budu postupovat podle pokynů, vysvětlovat krok za krokem a aktivně používat Excalidraw pro vizualizaci příkladů a postupů." }] },
                     // 3. Include previous chat history
                     ...historyForApi,
                     // 4. Add the current user request
                     currentRequestContent
                 ];

                 return contentsPayload;
            };


            /** Sends prompt to Gemini and processes the response. */
            const sendToGemini = async (userPromptText, targetArea) => {
                 // Pre-checks
                 if (!GEMINI_API_KEY || GEMINI_API_KEY === 'YOUR_GEMINI_API_KEY') {
                      showToast("Chyba: AI není správně nakonfigurována (chybí API klíč).", "error", 6000);
                      updateGeminiThinkingState(false);
                      updateAIStatus('Chyba konfigurace');
                      return;
                 }
                 if (!state.currentTopic) {
                      showToast("Chyba: Není vybráno žádné téma pro výuku.", "error");
                      updateGeminiThinkingState(false);
                      updateAIStatus('Chyba: Není téma');
                      return;
                 }
                 if (!navigator.onLine) {
                     showToast("Chyba: Jste offline. Zkontrolujte připojení k internetu.", "error");
                     updateGeminiThinkingState(false);
                     updateAIStatus('Offline');
                     return;
                 }


                 console.log(`Sending to Gemini (Target: ${targetArea}): "${userPromptText.substring(0, 100)}..."`);
                 updateAIStatus('AI přemýšlí...');
                 const requestTimestamp = new Date();
                 updateGeminiThinkingState(true); // Show thinking indicator, disable buttons

                 const contentsPayload = _buildGeminiPayloadContents(userPromptText, targetArea); // Build the prompt structure

                 const requestBody = {
                     contents: contentsPayload,
                     generationConfig: {
                         temperature: 0.5, // Balance creativity and predictability
                         topP: 0.95,
                         topK: 40,
                         maxOutputTokens: 8192 // Max allowed by Flash model
                     },
                      // Safety settings - adjust thresholds as needed, BLOCK_NONE is permissive
                     safetySettings: [
                         { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
                         { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
                         { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
                         { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" }
                     ]
                 };

                 try {
                     console.log("Sending payload to Gemini (first 500 chars):", JSON.stringify(requestBody).substring(0, 500) + "...");
                     const response = await fetch(GEMINI_API_URL, {
                         method: 'POST',
                         headers: { 'Content-Type': 'application/json' },
                         body: JSON.stringify(requestBody)
                     });

                     if (!response.ok) {
                         const errorBody = await response.text();
                         console.error("Gemini API Error Response:", response.status, errorBody);
                         throw new Error(`Chyba Gemini API (${response.status}): ${errorBody.substring(0, 150)}`);
                     }

                     const data = await response.json();
                     // console.log("Raw Gemini Response:", JSON.stringify(data)); // Log full response if needed for deep debug

                     const candidate = data.candidates?.[0];

                      // Check for blocking first
                      if (data.promptFeedback?.blockReason) {
                          console.error("Gemini request blocked:", data.promptFeedback);
                          throw new Error(`Obsah blokován: ${data.promptFeedback.blockReason}. Zkontrolujte prompt nebo bezpečnostní nastavení.`);
                      }
                      if (!candidate) {
                           console.error("Invalid response structure from Gemini (no candidates):", data);
                           throw new Error('Chybná struktura odpovědi od AI (chybí kandidát).');
                       }
                       // Check finish reason
                       if (candidate.finishReason && !["STOP", "MAX_TOKENS"].includes(candidate.finishReason)) {
                           console.warn(`Gemini generation finished unexpectedly: ${candidate.finishReason}. Safety Ratings:`, candidate.safetyRatings);
                           if(candidate.finishReason === 'SAFETY') {
                               throw new Error('Odpověď byla blokována bezpečnostním filtrem AI.');
                           }
                           // Potentially treat other reasons like MAX_TOKENS as non-fatal?
                       }


                     const geminiResponseText = candidate.content?.parts?.[0]?.text;

                     if (!geminiResponseText) {
                         console.warn("Gemini returned empty text content. Candidate:", candidate);
                          // If the finish reason was MAX_TOKENS, it's less of an error
                          if (candidate.finishReason === 'MAX_TOKENS') {
                               showToast("AI dosáhla maximální délky odpovědi.", "warning");
                               throw new Error('AI dosáhla maximální délky odpovědi.');
                          } else {
                               throw new Error('AI vrátila prázdnou odpověď.');
                          }
                     }

                     // --- Context Management: Add AFTER successful response ---
                     // Add the user prompt that LED to this response
                     state.geminiChatContext.push({ role: "user", parts: [{ text: userPromptText }] });
                     // Add the successful AI response
                     state.geminiChatContext.push({ role: "model", parts: [{ text: geminiResponseText }] });
                     // Optional: Limit context history size to prevent excessive payload
                      const MAX_HISTORY_TURNS = 10; // Keep last 10 pairs (user + model)
                      if (state.geminiChatContext.length > MAX_HISTORY_TURNS * 2) {
                           state.geminiChatContext = state.geminiChatContext.slice(-MAX_HISTORY_TURNS * 2);
                           console.log(`Trimmed Gemini context history to ${state.geminiChatContext.length} items.`);
                      }
                     // ---------------------------------------------------------

                     processGeminiResponse(geminiResponseText, targetArea, requestTimestamp);
                     updateAIStatus(state.currentTopic ? `Vysvětluje: ${state.currentTopic.name}` : 'Připraven');

                 } catch (error) {
                     console.error('Error sending/processing Gemini request:', error);
                     showToast(`Chyba komunikace s AI: ${error.message}`, "error", 6000);
                     handleGeminiError(error.message, targetArea, requestTimestamp); // Show error in UI
                     updateAIStatus('Nastala chyba');
                 } finally {
                     updateGeminiThinkingState(false); // Ensure thinking state is reset
                 }
            };


            /** Displays error messages in the UI after a Gemini API failure. */
            const handleGeminiError = (errorMessage, targetArea, timestamp) => {
                const errorMsg = `Omlouvám se, nastala chyba při zpracování: ${errorMessage}`;
                removeThinkingIndicator(); // Ensure thinking indicator is removed
                addChatMessage(errorMsg, 'gemini', false, timestamp); // Add error to chat

                // Optionally add error to explanation area too
                if (targetArea === 'explanation' && uiElements.explanationDisplay) {
                    const errorP = document.createElement('p');
                    errorP.style.color = 'var(--danger)';
                    errorP.style.marginTop = '1rem';
                    errorP.style.fontWeight = 'bold';
                    errorP.style.border = '1px dashed var(--danger)';
                    errorP.style.padding = '0.5rem';
                    errorP.textContent = errorMsg;
                    uiElements.explanationDisplay.appendChild(errorP);
                    // Scroll to error message
                    if (uiElements.explanationScrollContent) {
                        errorP.scrollIntoView({ behavior: 'smooth', block: 'end' });
                    }
                }
                updateAIStatus('Nastala chyba');
                manageButtonStates(); // Re-enable buttons after error
            };

            // --- Run Application ---
            document.addEventListener('DOMContentLoaded', initializeApp);

        } catch (e) {
            // --- Fatal Error Handling ---
            console.error("FATAL SCRIPT ERROR:", e);
            // Display a user-friendly error message covering the entire screen
            document.body.innerHTML = `
                <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: #f8d7da; color: #721c24; padding: 40px; text-align: center; font-family: sans-serif; z-index: 9999;">
                    <h1 style="font-size: 2em; margin-bottom: 20px;">Nastala kritická chyba aplikace</h1>
                    <p style="font-size: 1.1em; margin-bottom: 15px;">Omlouváme se, aplikace nemohla být správně spuštěna. Problém byl zaznamenán.</p>
                    <p style="margin-bottom: 25px;">Zkuste prosím <a href="#" onclick="window.location.reload();" style="color: #721c24; font-weight: bold;">obnovit stránku</a>.</p>
                    <details style="margin-top: 20px; text-align: left; background-color: #fff; padding: 15px; border: 1px solid #f5c6cb; border-radius: 5px;">
                        <summary style="cursor: pointer; font-weight: bold;">Technické detaily chyby</summary>
                        <pre style="margin-top: 10px; padding: 10px; background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; font-size: 0.8em; white-space: pre-wrap; word-wrap: break-word;">${e.message}\n${e.stack}</pre>
                    </details>
                </div>`;
        }
    </script>

</body>
</html>