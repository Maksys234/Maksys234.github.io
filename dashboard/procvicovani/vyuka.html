<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Justax - Interaktivní Výuka</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <script>
        // Konfigurace MathJax pro inline ($...$) a display ($$...) matematiku
        if (typeof window.MathJax === 'undefined') {
            window.MathJax = {
                tex: {
                    inlineMath: [ ['\\(', '\\)'], ['$', '$'] ], // Povolí $...$ i \(...\)
                    displayMath: [['$$', '$$']], // Povolí $$...$$
                    processEscapes: true, processEnvironments: true
                },
                options: { skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'], ignoreHtmlClass: 'tex2jax_ignore', processHtmlClass: 'tex2jax_process' },
                startup: { ready: () => { MathJax.startup.defaultReady(); MathJax.startup.promise.then(() => console.log('MathJax loaded and ready.')); } }
            };
        } else { console.warn("window.MathJax already defined."); }
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tooltipster/4.2.8/css/tooltipster.bundle.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tooltipster/4.2.8/js/tooltipster.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@excalidraw/excalidraw@0.17.3/dist/excalidraw.production.min.js" crossorigin></script>

    <style>
        /* --- CSS Styly --- */
        /* (Styly zůstávají stejné jako v původním souboru, zde zkráceno pro přehlednost) */
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Poppins', sans-serif; scroll-behavior: smooth; }
        :root { --primary-rgb: 67, 97, 238; --primary: #4361ee; --primary-light: #4895ef; --secondary: #3f37c9; --success: #06d6a0; --danger: #f72585; --warning: #f8961e; --info: #4cc9f0; --dark: #1e2a3a; --light: #f8f9fa; --gray: #6c757d; --gray-light: #dee2e6; --gray-dark: #343a40; --gradient-1: linear-gradient(135deg, #4361ee, #3a0ca3); --gradient-2: linear-gradient(135deg, #4cc9f0, #4361ee); --white: #ffffff; --sidebar-width: 260px; --transition-speed: 0.3s; --card-radius: 14px; --shadow-sm: 0 2px 6px rgba(0, 0, 0, 0.05); --shadow-md: 0 5px 12px rgba(0, 0, 0, 0.07); --shadow-lg: 0 10px 20px rgba(0, 0, 0, 0.1); --text-primary: #2d3748; --text-secondary: #4a5568; --text-muted: #718096; --call-bg: #f9fafb; --call-panel-bg: var(--white); --avatar-size: 40px; }
        body { background-color: var(--call-bg); color: var(--text-primary); min-height: 100vh; display: flex; overflow: hidden; font-size: 15px; }
        .sidebar { width: var(--sidebar-width); height: 100vh; position: fixed; top: 0; left: 0; background: var(--gradient-1); color: var(--white); padding: 1.5rem 1rem; display: flex; flex-direction: column; z-index: 1050; box-shadow: var(--shadow-lg); transition: transform var(--transition-speed) ease, width var(--transition-speed) ease; }
        .sidebar-header { display: flex; align-items: center; margin-bottom: 2rem; padding: 0 0.75rem; } .sidebar-logo { font-size: 1.6rem; font-weight: 700; color: var(--white); text-decoration: none; display: flex; align-items: center; gap: 0.8rem; transition: transform 0.2s ease; } .sidebar-logo:hover { transform: scale(1.03); } .sidebar-logo i { font-size: 1.8rem; } .sidebar-menu { list-style: none; padding: 0; margin: 0; flex-grow: 1; } .sidebar-item { margin-bottom: 0.5rem; } .sidebar-link { display: flex; align-items: center; padding: 0.85rem 1.1rem; color: rgba(255, 255, 255, 0.9); text-decoration: none; border-radius: 10px; transition: all 0.2s ease; font-weight: 500; position: relative; } .sidebar-link i { margin-right: 0.8rem; font-size: 1.25rem; width: 24px; text-align: center; transition: transform 0.2s ease; } .sidebar-link.active, .sidebar-link:hover { background-color: rgba(255, 255, 255, 0.2); color: var(--white); } .sidebar-link:hover i { transform: scale(1.1); } .sidebar-link.active::before { content: ''; position: absolute; left: 0; top: 50%; transform: translateY(-50%); width: 4px; height: 65%; background-color: var(--white); border-radius: 0 4px 4px 0; } .sidebar-footer { margin-top: auto; padding: 1rem; font-size: 0.85rem; color: rgba(255, 255, 255, 0.7); text-align: center; } .user-profile { display: flex; align-items: center; padding: 1rem; margin-top: 1rem; background-color: rgba(255, 255, 255, 0.1); border-radius: 10px; border: 1px solid rgba(255, 255, 255, 0.15); } .user-avatar { width: 42px; height: 42px; border-radius: 50%; background-color: var(--primary-light); display: flex; align-items: center; justify-content: center; margin-right: 0.8rem; font-weight: 500; overflow: hidden; color: var(--white); border: 2px solid rgba(255, 255, 255, 0.4); } .user-avatar img { width: 100%; height: 100%; object-fit: cover; } .user-info { flex-grow: 1; line-height: 1.3; } .user-name { font-weight: 600; font-size: 0.95rem; } .user-role { font-size: 0.8rem; opacity: 0.8; }
        main { flex: 1; margin-left: var(--sidebar-width); transition: margin var(--transition-speed) ease; width: calc(100% - var(--sidebar-width)); height: 100vh; display: flex; flex-direction: column; overflow: hidden; background-color: var(--call-bg); }
        .main-header { padding: 1rem 1.75rem; background-color: var(--white); box-shadow: 0 2px 4px rgba(0,0,0,0.04); display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; z-index: 100; border-bottom: 1px solid var(--gray-light); }
        .header-content h1 { font-size: 1.5rem; font-weight: 600; color: var(--dark); margin: 0; } .header-actions button, .header-actions a { font-size: 0.9rem; padding: 0.6rem 1.2rem; }
        .topic-loading-bar { padding: 0.9rem 1.75rem; background-color: var(--light); border-bottom: 1px solid var(--gray-light); display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 1rem; flex-shrink: 0; }
        #current-topic-display { font-size: 1.05rem; font-weight: 500; color: var(--text-secondary); } #current-topic-display strong { color: var(--primary); font-weight: 600; } #current-topic-display .placeholder { font-style: italic; color: var(--text-muted); } #current-topic-display .fa-spinner { margin-right: 0.5rem; }
        .call-interface { flex-grow: 1; display: flex; overflow: hidden; padding: 1.5rem; gap: 1.5rem; }
        .ai-presenter-area { flex-grow: 1; display: flex; flex-direction: column; background-color: var(--call-panel-bg); border-radius: var(--card-radius); box-shadow: var(--shadow-md); overflow: hidden; border: 1px solid var(--gray-light); min-width: 300px; transition: box-shadow var(--transition-speed) ease; height: 100%; min-height: 0; overflow: hidden; }
        .ai-presenter-area:hover { box-shadow: var(--shadow-lg); } .ai-presenter-header { padding: 0.8rem 1.25rem; border-bottom: 1px solid var(--gray-light); display: flex; align-items: center; gap: 0.8rem; background-color: #fdfdff; flex-shrink: 0; } .ai-avatar-placeholder { width: var(--avatar-size); height: var(--avatar-size); background: var(--gradient-1); border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-size: 1.5rem; flex-shrink: 0; box-shadow: var(--shadow-sm); } .ai-presenter-info h2 { font-size: 1.1rem; font-weight: 600; color: var(--dark); margin: 0; } .ai-presenter-info p { font-size: 0.85rem; color: var(--text-secondary); margin: 0; }
        #excalidraw-container { flex-grow: 1; position: relative; overflow: hidden; border-radius: 0 0 var(--card-radius) var(--card-radius); background-color: var(--white); min-height: 0; display: flex; box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.04); }
        #excalidraw-container > .excalidraw-wrapper { width: 100% !important; height: 100% !important; display: flex !important; flex-direction: column !important; } #excalidraw-container .excalidraw { width: 100% !important; height: 100% !important; min-height: 350px; border: none !important; flex-grow: 1 !important; } #excalidraw-container .loading-placeholder { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; flex-direction: column; color: var(--text-muted); background-color: var(--white); z-index: 5; } #excalidraw-container .loading-placeholder i { font-size: 2.5rem; color: var(--primary); margin-bottom: 1rem; animation: spinPulse 2s infinite ease-in-out; } #excalidraw-container .loading-placeholder p { font-size: 1rem; } @keyframes spinPulse { 0% { transform: scale(1) rotate(0deg); opacity: 0.7; } 50% { transform: scale(1.1) rotate(180deg); opacity: 1; } 100% { transform: scale(1) rotate(360deg); opacity: 0.7; } }
        .interaction-panel { width: 400px; flex-shrink: 0; display: flex; flex-direction: column; background-color: var(--call-panel-bg); border-radius: var(--card-radius); box-shadow: var(--shadow-md); overflow: hidden; border: 1px solid var(--gray-light); transition: box-shadow 0.3s ease; height: 100%; min-height: 0; }
        .interaction-panel:hover { box-shadow: var(--shadow-lg); } .interaction-tabs { display: flex; border-bottom: 1px solid var(--gray-light); background-color: #fdfdff; flex-shrink: 0; } .interaction-tab { flex: 1; text-align: center; padding: 0.9rem 1rem; font-weight: 500; color: var(--text-secondary); cursor: pointer; transition: all 0.2s ease; border-bottom: 3px solid transparent; font-size: 0.95rem; position: relative; } .interaction-tab:hover { color: var(--primary); background-color: rgba(var(--primary-rgb), 0.03); } .interaction-tab.active { color: var(--primary); border-bottom-color: var(--primary); font-weight: 600; background-color: var(--call-panel-bg); } .interaction-tab i { margin-right: 0.5rem; font-size: 1.05em; }
        .interaction-content-area { flex-grow: 1; overflow: hidden; position: relative; background-color: var(--call-panel-bg); min-height: 0; }
        .tab-content { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; overflow: hidden; visibility: hidden; opacity: 0; transition: opacity 0.3s ease, visibility 0s linear 0.3s; } .tab-content.active { visibility: visible; opacity: 1; transition: opacity 0.3s ease; }
        .explanation-scroll-content { flex-grow: 1; padding: 1.75rem; overflow-y: auto; scrollbar-width: thin; scrollbar-color: var(--gray-light) transparent; min-height: 0; } .explanation-scroll-content::-webkit-scrollbar { width: 8px; } .explanation-scroll-content::-webkit-scrollbar-track { background: transparent; } .explanation-scroll-content::-webkit-scrollbar-thumb { background-color: var(--gray-light); border-radius: 4px; border: 2px solid var(--call-panel-bg); }
        #explanation-display { line-height: 1.7; font-size: 0.95rem; } #explanation-display .step { margin-bottom: 1.5rem; padding: 1.25rem; border-radius: 10px; background-color: #ffffff; border: 1px solid #edf2f7; box-shadow: var(--shadow-sm); transition: box-shadow 0.2s ease, border-color 0.2s ease; } #explanation-display .step:hover { box-shadow: var(--shadow-md); border-color: #dbe4f0; } #explanation-display .step:last-child { margin-bottom: 0; } #explanation-display h3 { color: var(--secondary); margin-top: 0; margin-bottom: 0.8rem; font-size: 1.15rem; padding-bottom: 0.4rem; border-bottom: 1px solid var(--gray-light); } #explanation-display code { background-color: rgba(var(--primary-rgb), 0.07); padding: 0.2em 0.45em; border-radius: 4px; font-size: 0.9em; color: #3f37c9; border: 1px solid rgba(var(--primary-rgb), 0.1); } #explanation-display pre { margin: 1rem 0; } #explanation-display pre code { display: block; background-color: #f0f2f5; color: #333; padding: 1rem; border-radius: 6px; font-size: 0.9rem; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; border: 1px solid #e2e8f0; box-shadow: inset 0 1px 2px rgba(0,0,0,0.05); } #explanation-display strong { color: var(--dark); font-weight: 600; } #explanation-display blockquote { border-left: 4px solid var(--info); padding-left: 1rem; margin: 1rem 0 1rem 0.25rem; color: #4a5568; font-style: normal; background-color: rgba(76, 201, 240, 0.06); border-radius: 0 6px 6px 0; } #explanation-display ul, #explanation-display ol { margin-left: 1.25rem; margin-bottom: 0.8rem; padding-left: 1rem; } #explanation-display li { margin-bottom: 0.6rem; }
        .explanation-controls { flex-shrink: 0; margin-top: auto; padding: 1rem 1.75rem; border-top: 1px solid var(--gray-light); text-align: center; background-color: #f8f9fa; display: flex; justify-content: space-between; gap: 1rem; } .explanation-controls .btn { flex: 1; }
        #chat-tab-content { display: flex; flex-direction: column; height: 100%; }
        .chat-messages { flex-grow: 1; padding: 1.25rem; overflow-y: auto; scrollbar-color: var(--gray-light) var(--call-panel-bg); min-height: 0; }
        .chat-messages::-webkit-scrollbar { width: 8px; } .chat-messages::-webkit-scrollbar-track { background: var(--call-panel-bg); } .chat-messages::-webkit-scrollbar-thumb { background-color: var(--gray-light); border-radius: 4px; border: 2px solid var(--call-panel-bg); }
        .chat-input-area { flex-shrink: 0; padding: 1rem 1.25rem; background-color: #f8f9fa; border-top: 1px solid var(--gray-light); display: flex; align-items: flex-end; gap: 0.75rem; }
        .chat-message { display: flex; gap: 0.75rem; max-width: 92%; align-items: flex-end; margin-bottom: 1.25rem; /* border: 1px solid lime !important; */ /* DEBUG BORDER */ }
        .chat-message.user { margin-left: auto; flex-direction: row-reverse; } .message-avatar { width: var(--avatar-size); height: var(--avatar-size); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 500; font-size: 0.95rem; flex-shrink: 0; box-shadow: var(--shadow-sm); border: 2px solid var(--call-panel-bg); } .chat-message.user .message-avatar { background: var(--success); color: white; } .chat-message.model .message-avatar { background: var(--primary); color: white; } .message-bubble { padding: 0.8rem 1.2rem; border-radius: 16px; line-height: 1.6; word-wrap: break-word; box-shadow: var(--shadow-sm); position: relative; background-color: var(--white); color: var(--text-primary); border: 1px solid #eef2f7; transition: box-shadow 0.2s ease; } .message-bubble:hover { box-shadow: var(--shadow-md); } .chat-message.model .message-bubble { border-bottom-left-radius: 5px; background: linear-gradient(145deg, #ffffff, #f9faff); } .chat-message.user .message-bubble { background: var(--gradient-1); color: white; border: none; border-bottom-right-radius: 5px; } .message-bubble code { background-color: rgba(var(--primary-rgb), 0.07); padding: 0.15em 0.4em; border-radius: 4px; font-size: 0.9em; color: #3f37c9; border: 1px solid rgba(var(--primary-rgb), 0.1); } .chat-message.user .message-bubble code { background-color: rgba(255, 255, 255, 0.15); color: #e0e0ff; border: 1px solid rgba(255, 255, 255, 0.2); } .message-bubble pre { margin: 0.7rem 0; } .message-bubble pre code { display: block; background-color: #f0f2f5; color: #333; padding: 0.8rem; border-radius: 6px; font-size: 0.88rem; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; border: 1px solid #e2e8f0; box-shadow: inset 0 1px 2px rgba(0,0,0,0.05); } .chat-message.user .message-bubble pre code { background-color: rgba(0,0,0,0.3); color: #eee; border: 1px solid rgba(255,255,255,0.1); } .message-timestamp { font-size: 0.75rem; color: var(--text-muted); margin-top: 5px; display: block; text-align: left; opacity: 0.8; } .chat-message.user .message-timestamp { text-align: right; }
        .message-thinking-indicator { background: var(--white); display: flex; align-items: center; padding: 0.8rem 1.1rem; border-radius: 16px; box-shadow: var(--shadow-sm); border: 1px solid #eef2f7; width: fit-content; border-bottom-left-radius: 5px;} .typing-dot { width: 7px; height: 7px; background-color: var(--gray); border-radius: 50%; margin: 0 3px; display: inline-block; animation: typing 1.3s infinite ease-in-out; } .typing-dot:nth-child(2) { animation-delay: 0.2s; } .typing-dot:nth-child(3) { animation-delay: 0.4s; } @keyframes typing { 0%, 60%, 100% { transform: translateY(0); opacity: 0.5; } 30% { transform: translateY(-3px); opacity: 1; } }
        .chat-input { flex-grow: 1; padding: 0.8rem 1.1rem; border: 1px solid var(--gray-light); border-radius: 20px; font-size: 0.95rem; resize: none; max-height: 120px; overflow-y: auto; transition: border-color 0.2s ease, box-shadow 0.2s ease; line-height: 1.45; background-color: var(--white); } .chat-input:focus { outline: none; border-color: var(--primary); box-shadow: 0 0 0 3px rgba(var(--primary-rgb), 0.1); } .send-button { padding: 0 1.2rem; border-radius: 20px; font-weight: 600; font-size: 0.95rem; cursor: pointer; border: none; background: var(--gradient-1); color: white; transition: all 0.3s ease; flex-shrink: 0; height: 42px; display: flex; align-items: center; justify-content: center; box-shadow: var(--shadow-sm); } .send-button:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 5px 10px rgba(var(--primary-rgb), 0.2); } .send-button:active:not(:disabled) { transform: translateY(-1px); box-shadow: 0 3px 6px rgba(var(--primary-rgb), 0.15); } .send-button i { font-size: 1.1em; } .send-button .fa-spinner { margin: 0; }
        .chat-controls { flex-shrink: 0; padding: 0.5rem 1.25rem; font-size: 0.8rem; color: var(--text-muted); text-align: right; background-color: #f8f9fa; border-top: 1px solid var(--gray-light); } .chat-controls button { background:none; border:none; color: var(--text-muted); cursor:pointer; font-size: 0.95em; padding: 3px 6px; margin-left: 10px; transition: color 0.2s ease; } .chat-controls button:hover { color: var(--primary); }
        .loading-placeholder { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 2rem; text-align: center; font-style: italic; color: var(--text-muted); flex-grow: 1; min-height: 150px; } .loading-placeholder i { margin-bottom: 1rem; font-size: 2.2rem; color: var(--primary-light); animation: spin 1.5s linear infinite; } @keyframes spin { to { transform: rotate(360deg); } }
        .empty-state { text-align: center; padding: 2rem 1.5rem; color: var(--text-secondary); margin-top: 1rem; flex-grow: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 150px; } .empty-state i { font-size: 3rem; margin-bottom: 1.25rem; color: var(--gray-light); opacity: 0.7; } .empty-state h3 { font-size: 1.2rem; font-weight: 600; margin-bottom: 0.8rem; color: var(--dark); } .empty-state p { margin-bottom: 1.25rem; max-width: 450px; margin-left: auto; margin-right: auto; line-height: 1.55; }
        .btn { display: inline-flex; align-items: center; justify-content: center; padding: 0.7rem 1.4rem; border-radius: 8px; font-weight: 500; font-size: 0.9rem; text-decoration: none; transition: all 0.25s ease; cursor: pointer; border: none; gap: 0.5rem; line-height: 1.5; } .btn-primary { background: var(--gradient-1); color: white; box-shadow: var(--shadow-sm); } .btn-primary:hover:not(:disabled) { transform: translateY(-2px); box-shadow: var(--shadow-md); background: linear-gradient(135deg, var(--primary-light), var(--secondary)); } .btn-secondary { background-color: var(--white); color: var(--text-secondary); border: 1px solid var(--gray-light); box-shadow: var(--shadow-sm); } .btn-secondary:hover:not(:disabled) { background-color: #f8f9fa; color: var(--primary); border-color: var(--primary-light); } .btn-success { background: linear-gradient(135deg, var(--success), #05a381); color: white; box-shadow: var(--shadow-sm); } .btn-success:hover:not(:disabled) { transform: translateY(-2px); box-shadow: var(--shadow-md); background: linear-gradient(135deg, #0cd1a7, var(--success));} .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none !important; box-shadow: none !important; background: var(--gray); color: var(--white); border: none; } .btn i { font-size: 1em; }
        mjx-math[display="inline"] { color: var(--secondary); background-color: rgba(var(--primary-rgb), 0.1); padding: 0.15em 0.4em; border-radius: 4px; font-weight: 500; border: 1px solid rgba(var(--primary-rgb), 0.15); display: inline-block; line-height: 1; margin: 0 1px; vertical-align: baseline; box-shadow: 0 1px 2px rgba(0,0,0,0.05); } .chat-message.user .message-bubble mjx-math[display="inline"] { color: #cdeeff; background-color: rgba(255, 255, 255, 0.1); border-color: rgba(255, 255, 255, 0.15); box-shadow: none; } #explanation-display .step mjx-math[display="inline"] { background-color: rgba(var(--primary-rgb), 0.08); border-color: rgba(var(--primary-rgb), 0.12); }
        .mobile-menu-toggle { display: none; background: none; border: none; cursor: pointer; color: var(--dark); font-size: 1.6rem; margin-right: 1rem; padding: 0.5rem; z-index: 1060; transition: color 0.2s ease; } .mobile-menu-toggle:hover { color: var(--primary); }
        .sidebar-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.55); z-index: 1040; opacity: 0; transition: opacity 0.3s ease; backdrop-filter: blur(5px); } .sidebar-overlay.active { display: block; opacity: 1; }
        @keyframes fadeIn { 0% { opacity: 0; transform: translateY(8px); } 100% { opacity: 1; transform: translateY(0); } }
        @media (max-width: 1200px) { .interaction-panel { width: 340px; } .call-interface { padding: 1.2rem; gap: 1.2rem; } }
        @media (max-width: 992px) { :root { --sidebar-width: 80px; } .sidebar { width: 80px; } .sidebar-logo span, .sidebar-link span, .user-info, .sidebar-footer { display: none; } .sidebar-link i { margin-right: 0; font-size: 1.5rem; } .sidebar-logo i { margin-right: 0; } .sidebar-header, .sidebar-link { justify-content: center; } .user-profile { justify-content: center; padding: 0.75rem 0; } .user-avatar { margin-right: 0; } main { margin-left: 80px; width: calc(100% - 80px); } .call-interface { flex-direction: column; padding: 1rem; gap: 1rem; } .interaction-panel { width: 100%; height: 55vh; flex-grow: 0; flex-shrink: 1; order: 1; } .ai-presenter-area { height: 45vh; min-height: 280px; order: 2; flex-grow: 0; flex-shrink: 1; } #excalidraw-container { min-height: 200px; } }
        @media (max-width: 768px) { .main-header { padding: 0.8rem 1.2rem; } .header-content h1 { font-size: 1.3rem; } .interaction-tab { padding: 0.8rem 0.5rem; font-size: 0.9rem; } .chat-input { font-size: 0.9rem; padding: 0.7rem 1rem; } .send-button { height: 40px; padding: 0 1rem; } .btn { padding: 0.6rem 1.2rem; font-size: 0.85rem; } .interaction-panel { height: 60vh; } .ai-presenter-area { height: 40vh; } }
        @media (max-width: 576px) { :root { --sidebar-width: 0; } .sidebar { transform: translateX(-100%); z-index: 1050; width: 260px; } .sidebar.active { transform: translateX(0); } .sidebar.active .sidebar-logo span, .sidebar.active .sidebar-link span, .sidebar.active .user-info, .sidebar.active .sidebar-footer { display: block; } .sidebar.active .sidebar-link i { margin-right: 0.75rem; font-size: 1.25rem; } .sidebar.active .sidebar-header, .sidebar.active .sidebar-link { justify-content: flex-start; } .sidebar.active .user-profile { justify-content: flex-start; padding: 1rem; } .sidebar.active .user-avatar { margin-right: 0.75rem; } main { margin-left: 0; width: 100%; } .mobile-menu-toggle { display: block; } .main-header { padding: 0.7rem 1rem; } .header-content h1 { font-size: 1.15rem; } .call-interface { padding: 0.8rem; gap: 0.8rem; } .ai-presenter-area { min-height: 220px; } .message-bubble { padding: 0.7rem 1rem; } .chat-input { padding: 0.6rem 0.9rem; } .send-button { height: 38px; padding: 0 0.9rem; } }
        @media (prefers-color-scheme: dark) { :root { --white: #1a202c; --light: #2d3748; --dark: #e2e8f0; --gray-light: #4a5568; --text-primary: #e2e8f0; --text-secondary: #cbd5e0; --text-muted: #a0aec0; --dark-bg: #171923; --call-bg: #131720; --call-panel-bg: #1e2533; } body { background-color: var(--dark-bg); } main { background-color: var(--call-bg); } .main-header { background-color: var(--call-panel-bg); border-bottom-color: var(--gray-light); } .mobile-menu-toggle { color: var(--dark); } .ai-presenter-area, .interaction-panel { background-color: var(--call-panel-bg); box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3); border-color: var(--gray-light); } .ai-presenter-header { background-color: #242c3b; border-bottom-color: var(--gray-light); } #excalidraw-container { background-color: #ffffff; box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1); } #excalidraw-container .loading-placeholder { background-color: #1e2533; color: var(--text-muted); } #excalidraw-container .loading-placeholder i { color: var(--primary-light); } .interaction-tabs { background-color: #242c3b; border-bottom-color: var(--gray-light); } .interaction-tab { color: var(--text-secondary); } .interaction-tab:hover { color: var(--primary-light); background-color: rgba(72, 149, 239, 0.1); } .interaction-tab.active { color: var(--primary-light); border-bottom-color: var(--primary-light); background-color: var(--call-panel-bg); } .tab-content { background-color: var(--call-panel-bg); } .explanation-scroll-content { scrollbar-color: var(--gray) var(--call-panel-bg); } .explanation-scroll-content::-webkit-scrollbar-thumb { border-color: var(--call-panel-bg); } #explanation-display .step { background-color: #232a37; border-color: #3b4458; } #explanation-display pre code { background-color: #161a22; color: #d1d5db; border-color: #363d4b; } #explanation-display code { background-color: rgba(72, 149, 239, 0.15); color: var(--primary-light); border-color: rgba(72, 149, 239, 0.25); } #explanation-display strong { color: #f0f2f5; } #explanation-display blockquote { border-left-color: var(--primary); color: #a0b3d0; background-color: #242c3b; } .explanation-controls { background-color: #242c3b; border-top-color: var(--gray-light); } .chat-messages { scrollbar-color: var(--gray) var(--call-panel-bg); } .chat-messages::-webkit-scrollbar-track { background: var(--call-panel-bg); } .chat-messages::-webkit-scrollbar-thumb { border-color: var(--call-panel-bg); } .message-avatar { border-color: var(--call-panel-bg); } .message-bubble { background-color: var(--light); color: var(--text-primary); border-color: #3b4458; } .chat-message.user .message-bubble { background: var(--gradient-2); color: #1a202c; } .message-bubble code { background-color: rgba(255,255,255,0.08); color: var(--text-primary); border-color: rgba(255,255,255,0.12); } .chat-message.user .message-bubble code { background-color: rgba(0, 0, 0, 0.15); color: #2d3748; border-color: rgba(0,0,0,0.2); } .message-bubble pre code { background-color: #161a22; color: #d1d5db; border-color: #363d4b; } .chat-message.user .message-bubble pre code { background-color: rgba(0,0,0,0.25); color: #eee; } .message-thinking-indicator { background: var(--light); border-color: #3b4458;} .typing-dot { background-color: #8494a6; } .chat-input-area { background-color: #242c3b; border-top-color: var(--gray-light); } .chat-input { background-color: var(--dark-bg); color: var(--text-primary); border-color: var(--gray-light); } .chat-input::placeholder { color: var(--text-muted); } .chat-input:focus { box-shadow: 0 0 0 3px rgba(var(--primary-rgb), 0.2); } .chat-controls { background-color: #242c3b; border-top-color: var(--gray-light); } .chat-controls button { color: var(--text-muted); } .chat-controls button:hover { color: var(--primary-light); } .btn-secondary { background-color: var(--light); color: var(--text-secondary); border-color: var(--gray-light); } .btn-secondary:hover:not(:disabled) { background-color: #4a5568; color: var(--white); border-color: #6c757d; } .btn-success { background: linear-gradient(135deg, var(--success), #05a381); } .btn-success:hover:not(:disabled) { background: linear-gradient(135deg, #0cd1a7, var(--success));} .btn:disabled { background: #4a5568; color: #a0aec0; } .topic-loading-bar { background-color: var(--light); border-bottom-color: var(--gray-light); } .empty-state i { color: #4a5568; } .toast { background-color: var(--call-panel-bg); border-color: var(--gray-light); color: var(--text-primary); box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);} mjx-math[display="inline"] { color: var(--primary-light); background-color: rgba(72, 149, 239, 0.15); border-color: rgba(72, 149, 239, 0.25); box-shadow: 0 1px 2px rgba(0,0,0,0.1); } .chat-message.user .message-bubble mjx-math[display="inline"] { color: #eee; background-color: rgba(255, 255, 255, 0.08); border-color: rgba(255, 255, 255, 0.1); box-shadow: none; } #explanation-display .step mjx-math[display="inline"] { background-color: rgba(72, 149, 239, 0.15); border-color: rgba(72, 149, 239, 0.2); } }
        .toast { position: fixed; bottom: 20px; right: 20px; background-color: var(--white); color: var(--text-primary); border-radius: 8px; padding: 1rem 1.2rem; box-shadow: var(--shadow-lg); max-width: 320px; z-index: 1001; display: flex; align-items: center; transform: translateX(calc(100% + 30px)); opacity: 0; transition: all 0.4s cubic-bezier(0.68, -0.55, 0.27, 1.55); } .toast.show { transform: translateX(0); opacity: 1; } .toast.success { border-left: 4px solid var(--success); } .toast.success i { color: var(--success); } .toast.error { border-left: 4px solid var(--danger); } .toast.error i { color: var(--danger); } .toast.warning { border-left: 4px solid var(--warning); } .toast.warning i { color: var(--warning); } .toast.info { border-left: 4px solid var(--info); } .toast.info i { color: var(--info); } .toast i { margin-right: 0.8rem; font-size: 1.3rem; }

    </style>
</head>
<body>
    <div id="sidebar-overlay" class="sidebar-overlay"></div>

    <aside id="sidebar" class="sidebar">
        <div class="sidebar-header">
            <a href="/" class="sidebar-logo">
                <i class="fas fa-calculator"></i> <span>Justax</span>
            </a>
        </div>
        <ul class="sidebar-menu">
            <li class="sidebar-item"> <a href="/dashboard/dashboard.html" class="sidebar-link"> <i class="fas fa-th-large"></i> <span>Dashboard</span> </a> </li>
            <li class="sidebar-item"> <a href="/dashboard/procvicovani/main.html" class="sidebar-link active"> <i class="fas fa-book-open"></i> <span>Procvičování</span> </a> </li>
            <li class="sidebar-item"> <a href="/dashboard/pokrok.html" class="sidebar-link"> <i class="fas fa-chart-line"></i> <span>Pokrok</span> </a> </li>
            <li class="sidebar-item"> <a href="/dashboard/oceneni.html" class="sidebar-link"> <i class="fas fa-medal"></i> <span>Ocenění</span> </a> </li>
            <li class="sidebar-item"> <a href="/dashboard/materialy.html" class="sidebar-link"> <i class="fas fa-file-alt"></i> <span>Materiály</span> </a> </li>
            <li class="sidebar-item"> <a href="/dashboard/profile.html" class="sidebar-link"> <i class="fas fa-user-cog"></i> <span>Profil</span> </a> </li>
        </ul>
        <div class="user-profile">
            <div class="user-avatar" id="user-avatar">?</div>
            <div class="user-info">
                <div class="user-name" id="user-name">Načítání...</div>
                <div class="user-role">Student</div>
            </div>
        </div>
        <div class="sidebar-footer"> &copy; 2025 Justax </div>
    </aside>

    <main>
        <div class="main-header">
            <div class="header-content">
                <div style="display: flex; align-items: center; gap: 1rem;">
                    <button class="mobile-menu-toggle" id="mobile-menu-toggle"> <i class="fas fa-bars"></i> </button>
                    <h1>Interaktivní výuka</h1>
                </div>
                <div class="header-actions">
                    <a href="/dashboard/procvicovani/main.html" class="btn btn-secondary"> <i class="fas fa-times"></i> Ukončit výuku </a>
                </div>
            </div>
        </div>

        <div class="topic-loading-bar">
            <div id="current-topic-display"><span class="placeholder">Načítám data...</span></div>
        </div>

        <div class="call-interface" style="display: none;">
            <div class="ai-presenter-area">
                <div class="ai-presenter-header">
                    <div class="ai-avatar-placeholder"> <i class="fas fa-chalkboard-teacher"></i> </div>
                    <div class="ai-presenter-info">
                        <h2>AI Tutor Justax</h2>
                        <p id="ai-status-text">Čekání na téma...</p>
                    </div>
                </div>
                <div id="excalidraw-container">
                    <div class="loading-placeholder"><i class="fas fa-spinner"></i><p>Načítám kreslící plochu...</p></div>
                </div>
            </div>

            <div class="interaction-panel">
                <div class="interaction-tabs">
                    <div class="interaction-tab active" data-tab="explanation-tab"> <i class="fas fa-graduation-cap"></i> Vysvětlení </div>
                    <div class="interaction-tab" data-tab="chat-tab"> <i class="fas fa-comments"></i> Chat </div>
                </div>
                <div class="interaction-content-area">
                    <div id="explanation-tab-content" class="tab-content active">
                        <div class="explanation-scroll-content">
                            <div id="explanation-display">
                                <div class="empty-state">
                                    <i class="fas fa-book-reader"></i>
                                    <h3>Výuka připravena</h3>
                                    <p>Počkejte na automatické načtení tématu nebo vyberte téma ručně (pokud je implementováno).</p>
                                </div>
                            </div>
                        </div>
                        <div class="explanation-controls">
                            <button class="btn btn-primary btn-tooltip" id="next-step-btn" style="display: none;" title="Požádat AI o další krok vysvětlení">
                                <i class="fas fa-forward"></i> Další krok
                            </button>
                            <button class="btn btn-success btn-tooltip" id="mark-complete-btn" style="display: none;" title="Označit aktuální téma jako probrané">
                                <i class="fas fa-check-circle"></i> Téma dokončeno
                            </button>
                        </div>
                    </div>
                    <div id="chat-tab-content" class="tab-content">
                        <section class="chat-area" style="display: flex; flex-direction: column; height: 100%;">
                            <div class="chat-messages" id="chat-messages">
                                </div>
                            <div class="chat-input-area">
                                <textarea class="chat-input" id="chat-input" placeholder="Zeptej se na cokoli k tématu..." rows="1"></textarea>
                                <button class="send-button" id="send-button" title="Odeslat zprávu">
                                    <i class="fas fa-paper-plane"></i>
                                </button>
                            </div>
                            <div class="chat-controls">
                                <button id="clear-chat-btn" class="btn-tooltip" title="Vymazat historii tohoto chatu">
                                    <i class="fas fa-trash-alt"></i> Vymazat
                                </button>
                                |
                                <button id="save-chat-btn" class="btn-tooltip" title="Uložit chat jako PDF">
                                    <i class="fas fa-save"></i> Uložit PDF
                                </button>
                            </div>
                        </section>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <div class="toast" id="toast">
        <i class="fas fa-info-circle"></i>
        <div id="toast-message">Operace úspěšná.</div>
    </div>

    <script>
        // Wrap the entire script in a try-catch block for robust error handling
        try {
            // --- Constants & Configuration ---
            const SUPABASE_URL = 'https://qcimhjjwvsbgjsitmvuh.supabase.co';
            const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFjaW1oamp3dnNiZ2pzaXRtdnVoIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDI1ODA5MjYsImV4cCI6MjA1ODE1NjkyNn0.OimvRtbXuIUkaIwveOvqbMd_cmPN5yY3DbWCBYc9D10';
            const GEMINI_API_KEY = 'AIzaSyDQboM6qtC_O2sqqpaKZZffNf2zk6HrhEs'; // !!! SECURITY WARNING: Hardcoding API keys is insecure. Use environment variables or a backend proxy in production!
            const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${GEMINI_API_KEY}`;
            const EXCALIDRAW_SCENE_REGEX = /EXCALIDRAW_SCENE:\s*```json\s*(\[[\s\S]*?\])\s*```\s*/g; // Regex to extract Excalidraw data

            // --- DOM Elements Cache ---
            // Cache frequently accessed DOM elements for performance and easier access
            const uiElements = {
                userAvatar: document.getElementById('user-avatar'),
                userName: document.getElementById('user-name'),
                mobileMenuToggle: document.getElementById('mobile-menu-toggle'),
                sidebar: document.getElementById('sidebar'),
                sidebarOverlay: document.getElementById('sidebar-overlay'),
                currentTopicDisplay: document.getElementById('current-topic-display'),
                explanationDisplay: document.getElementById('explanation-display'),
                explanationScrollContent: document.querySelector('.explanation-scroll-content'),
                excalidrawContainer: document.getElementById('excalidraw-container'),
                chatMessages: document.getElementById('chat-messages'),
                chatInput: document.getElementById('chat-input'),
                sendButton: document.getElementById('send-button'),
                saveChatBtn: document.getElementById('save-chat-btn'),
                clearChatBtn: document.getElementById('clear-chat-btn'),
                nextStepBtn: document.getElementById('next-step-btn'),
                markCompleteBtn: document.getElementById('mark-complete-btn'),
                toast: document.getElementById('toast'),
                toastMessage: document.getElementById('toast-message'),
                interactionTabs: document.querySelectorAll('.interaction-tab'),
                tabContents: document.querySelectorAll('.tab-content'),
                aiStatusText: document.getElementById('ai-status-text'),
                callInterface: document.querySelector('.call-interface')
            };

            // --- Global State ---
            // Store application state in one place
            let state = {
                supabase: null,                 // Supabase client instance
                currentUser: null,              // Logged-in user object
                currentProfile: null,           // User profile data
                currentTopic: null,             // Current learning topic object { activity_id, plan_id, name, description, topic_id }
                currentPlanId: null,            // ID of the active study plan
                currentSessionId: null,         // Unique ID for the current learning session
                geminiChatContext: [],          // History for Gemini API calls
                excalidrawAPI: null,            // Excalidraw API instance
                excalidrawElements: [],         // Current elements on the Excalidraw canvas
                excalidrawRoot: null,           // React root for Excalidraw
                geminiIsThinking: false,        // Flag indicating if Gemini is processing
                thinkingIndicatorId: null,      // ID of the "thinking" chat bubble
                topicLoadInProgress: false,     // Flag to prevent concurrent topic loading
                lastExplanationTimestamp: 0,    // Timestamp of the last explanation step
                activeInteractionTab: 'explanation-tab' // Currently active tab ('explanation' or 'chat')
            };

            // --- Utility Functions ---

            /** Sanitizes a string to prevent XSS attacks when inserting into HTML. */
            const sanitizeHTML = (str) => {
                const temp = document.createElement('div');
                temp.textContent = str || ''; // Use textContent to prevent HTML interpretation
                return temp.innerHTML; // Return the escaped HTML
            };

            /** Generates initials from user profile or email. */
            const getInitials = (profile, email) => {
                if (!profile && !email) return '?';
                let initials = '';
                if (profile?.first_name) initials += profile.first_name[0];
                if (profile?.last_name) initials += profile.last_name[0];
                if (initials) return initials.toUpperCase();
                if (profile?.username) return profile.username[0].toUpperCase();
                if (email) return email[0].toUpperCase();
                return 'U';
            };

            /** Displays a toast notification. */
            const showToast = (message, type = 'info', duration = 4000) => {
                if (!uiElements.toast || !uiElements.toastMessage) return;
                console.log(`Toast (${type}): ${message}`);
                uiElements.toastMessage.textContent = message;
                const icon = uiElements.toast.querySelector('i');
                uiElements.toast.className = 'toast ' + type; // Set base class and type class
                // Update icon based on type
                icon.className = `fas ${type === 'success' ? 'fa-check-circle' : type === 'error' ? 'fa-exclamation-circle' : type === 'warning' ? 'fa-exclamation-triangle' : 'fa-info-circle'}`;
                uiElements.toast.classList.add('show'); // Trigger animation
                // Hide toast after duration
                setTimeout(() => uiElements.toast.classList.remove('show'), duration);
            };

            /** Renders Markdown text into an HTML element using the Marked.js library. */
            const renderMarkdown = (element, markdownText) => {
                if (!element) return;
                console.log("Rendering Markdown in element:", element);
                try {
                    element.innerHTML = marked.parse(markdownText || ''); // Use marked.parse
                } catch (e) {
                    console.error("Markdown rendering error:", e);
                    element.innerHTML = `<p style="color:red;">Chyba renderování Markdownu.</p><pre>${sanitizeHTML(markdownText)}</pre>`;
                }
            };

            /** Automatically adjusts the height of the chat textarea based on content. */
            const autoResizeTextarea = () => {
                if (!uiElements.chatInput) return;
                uiElements.chatInput.style.height = 'auto'; // Reset height
                const scrollHeight = uiElements.chatInput.scrollHeight;
                const maxHeight = 150; // Max height in pixels
                uiElements.chatInput.style.height = `${Math.min(scrollHeight, maxHeight)}px`;
                uiElements.chatInput.style.overflowY = scrollHeight > maxHeight ? 'scroll' : 'hidden'; // Show scrollbar if needed
            };

            /** Generates a unique ID for the learning session. */
            const generateSessionId = () => `session_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;

            /** Formats a date object into a HH:MM time string. */
            const formatTimestamp = (date = new Date()) => date.toLocaleTimeString('cs-CZ', { hour: '2-digit', minute: '2-digit' });

            /** Updates the status text displayed under the AI Tutor's name. */
            const updateAIStatus = (text) => {
                if (uiElements.aiStatusText) uiElements.aiStatusText.textContent = text;
            };

            // --- Initialization Functions ---

            /** Initializes the Supabase client. Returns true on success, false on failure. */
            const initializeSupabase = () => {
                console.log("Initializing Supabase...");
                try {
                    // Ensure the Supabase library is loaded globally
                    if (typeof window.supabase === 'undefined' || typeof window.supabase.createClient !== 'function') {
                        throw new Error("Supabase library not loaded or invalid.");
                    }
                    state.supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                    if (!state.supabase) throw new Error("Supabase client creation failed.");
                    console.log("Supabase client initialized.");
                    return true;
                } catch (error) {
                    console.error("Supabase initialization failed:", error);
                    showToast("Chyba připojení k databázi.", "error", 10000); // Show longer error
                    return false;
                }
            };

            /** Initializes UI components like Excalidraw, sets up event listeners, and tooltips. Returns true on success, false on failure. */
            const initializeUI = () => {
                console.log("Initializing UI elements and Excalidraw...");
                if (!initializeExcalidraw()) {
                    showToast("Chyba inicializace Excalidraw!", "error", 10000);
                    if(uiElements.callInterface) uiElements.callInterface.style.display = 'none'; // Hide interface on Excalidraw fail
                    if(uiElements.currentTopicDisplay) uiElements.currentTopicDisplay.innerHTML = '<span class="placeholder" style="color:var(--danger);">Chyba Excalidraw</span>';
                    return false;
                }
                // Restore last active tab from session storage, default to explanation
                const lastTab = sessionStorage.getItem('activeVyukaTab');
                switchInteractionTab(lastTab || 'explanation-tab');
                setupEventListeners();
                initTooltips();
                manageUIState('initial'); // Set initial UI state
                manageButtonStates(); // Set initial button disabled states
                return true;
            };

            /** Main application entry point. Initializes Supabase, UI, loads user profile, and starts topic loading. */
            const initializeApp = async () => {
                console.log("DOM Loaded. Initializing Justax AI Tutor (Excalidraw Mode)...");
                if (!initializeSupabase()) return; // Stop if Supabase fails
                if (!initializeUI()) return; // Stop if UI fails

                console.log("Loading user profile...");
                await loadUserProfile();

                if (state.currentUser) {
                    console.log("User logged in, loading topic...");
                    await loadNextUncompletedTopic(); // Load the first topic for the logged-in user
                } else {
                    handleLoggedOutUser(); // Handle the case where no user is logged in
                }
            };

            // --- UI State Management ---

            /** Manages the overall visibility and state of UI sections based on the application mode. */
            const manageUIState = (mode) => {
                console.log("Managing UI State:", mode);

                // Determine if the main call interface should be visible
                const showCallInterface = state.currentTopic && !['loggedOut', 'noPlan', 'planComplete'].includes(mode);

                // Show/Hide the main call interface
                if (uiElements.callInterface) {
                    if (!showCallInterface && !['learning', 'requestingExplanation', 'loadingTopic'].includes(mode)) {
                         // Hide if no topic OR in a final/error state, AND not actively loading/explaining
                         uiElements.callInterface.style.display = 'none';
                         console.log("Hiding call interface based on mode:", mode);
                    } else if (showCallInterface || ['learning', 'requestingExplanation', 'loadingTopic'].includes(mode)) {
                         // Show if there's a topic OR actively loading/explaining
                         uiElements.callInterface.style.display = 'flex';
                         console.log("Showing call interface based on mode:", mode);
                    }
                }

                // Update the explanation display based on the mode
                if (mode === 'initial' || mode === 'loggedOut' || mode === 'noPlan' || mode === 'planComplete' || mode === 'error') {
                    // Display placeholder/status messages in the explanation area for non-learning states
                    let message = "<div class='empty-state'><i class='fas fa-book-reader'></i><h3>Výuka připravena</h3><p>Čekám na data...</p></div>";
                    if(mode === 'loggedOut') message = "<div class='empty-state'><i class='fas fa-sign-in-alt'></i><h3>Nejste přihlášeni</h3><p>Přihlaste se prosím pro zahájení výuky.</p></div>";
                    if(mode === 'noPlan') message = "<div class='empty-state'><i class='fas fa-calendar-times'></i><h3>Žádný plán</h3><p>Nemáte aktivní studijní plán.</p></div>";
                    if(mode === 'planComplete') message = "<div class='empty-state'><i class='fas fa-check-circle'></i><h3>Plán dokončen</h3><p>Gratulujeme, všechna témata jsou hotová!</p></div>";
                    if(mode === 'error') message = "<div class='empty-state'><i class='fas fa-exclamation-triangle'></i><h3>Chyba</h3><p>Při načítání dat došlo k chybě.</p></div>";
                    if(uiElements.explanationDisplay) uiElements.explanationDisplay.innerHTML = message;
                } else if (mode === 'loadingTopic') {
                    // Show loading spinner while fetching the topic
                    if(uiElements.explanationDisplay) uiElements.explanationDisplay.innerHTML = "<div class='loading-placeholder'><i class='fas fa-spinner fa-spin'></i><p>Načítám téma...</p></div>";
                } else if (mode === 'requestingExplanation') {
                     // Show loading spinner if explanation area is empty when starting a topic
                     if(uiElements.explanationDisplay && (!uiElements.explanationDisplay.hasChildNodes() || uiElements.explanationDisplay.querySelector('.empty-state'))) {
                         uiElements.explanationDisplay.innerHTML = "<div class='loading-placeholder'><i class='fas fa-spinner fa-spin'></i><p>Požaduji úvodní vysvětlení...</p></div>";
                     }
                     // Otherwise, keep the existing explanation visible while loading the next step
                }
                // Note: 'learning' state doesn't clear the explanation display, allowing steps to accumulate.
            };

            /** Manages the enabled/disabled state and content of buttons based on application state. */
            const manageButtonStates = () => {
                const enableSend = !state.geminiIsThinking && !!state.currentTopic;
                const enableNext = !state.geminiIsThinking && !!state.currentTopic;
                const enableComplete = !state.geminiIsThinking && !!state.currentTopic;

                if (uiElements.sendButton) {
                    uiElements.sendButton.disabled = !enableSend;
                    // Show spinner or send icon
                    uiElements.sendButton.innerHTML = state.geminiIsThinking ? '<i class="fas fa-spinner fa-spin"></i>' : '<i class="fas fa-paper-plane"></i>';
                }
                if (uiElements.nextStepBtn) {
                    uiElements.nextStepBtn.disabled = !enableNext;
                    // Show button only if there's a current topic
                    uiElements.nextStepBtn.style.display = state.currentTopic ? 'inline-flex' : 'none';
                }
                if (uiElements.markCompleteBtn) {
                    uiElements.markCompleteBtn.disabled = !enableComplete;
                    // Show button only if there's a current topic
                    uiElements.markCompleteBtn.style.display = state.currentTopic ? 'inline-flex' : 'none';
                }
            };

            // --- Excalidraw Functions ---

            /** Initializes the Excalidraw component using React. */
            const initializeExcalidraw = () => {
                console.log("Initializing Excalidraw...");
                const container = uiElements.excalidrawContainer;
                if (!container) {
                    console.error("Excalidraw container not found!");
                    return false;
                }
                // Check if required libraries are loaded
                if (typeof React === 'undefined' || typeof ReactDOM === 'undefined' || typeof ExcalidrawLib === 'undefined') {
                    console.error("React, ReactDOM, or Excalidraw library not loaded!");
                    container.innerHTML = '<p style="color:red; padding: 1rem;">Chyba: Potřebné knihovny (React, Excalidraw) nebyly načteny.</p>';
                    return false;
                }

                try {
                    // Show loading placeholder initially
                    container.innerHTML = '<div class="loading-placeholder"><i class="fas fa-spinner"></i><p>Načítám kreslící plochu...</p></div>';

                    // Create a React root for the container
                    state.excalidrawRoot = ReactDOM.createRoot(container);

                    // Initial data for Excalidraw (empty canvas, view mode enabled)
                    const initialData = {
                        appState: {
                            viewBackgroundColor: "#ffffff",
                            currentItemFontFamily: 1, // Virgil
                            currentItemFontSize: 20,
                            theme: 'light',
                            viewModeEnabled: true // Start in view mode
                        },
                        elements: [], // Start with empty elements
                        scrollToContent: true
                    };

                    // Render the Excalidraw component
                    state.excalidrawRoot.render(
                        React.createElement(ExcalidrawLib.Excalidraw, {
                            initialData: initialData,
                            // Callback to get the Excalidraw API instance
                            excalidrawAPI: (api) => {
                                state.excalidrawAPI = api;
                                console.log("Excalidraw API ready.");
                                // Remove loading placeholder once API is ready
                                const placeholder = container.querySelector('.loading-placeholder');
                                if (placeholder) placeholder.remove();
                                // Ensure canvas is truly empty initially (sometimes initialData elements persist briefly)
                                const currentElements = api.getSceneElements();
                                if (currentElements && currentElements.length > 0) {
                                    api.updateScene({ elements: [] });
                                }
                            },
                            // Configure UI options (disable file operations)
                            UIOptions: {
                                canvasActions: {
                                    saveToActiveFile: false,
                                    loadScene: false,
                                    clearCanvas: false // Clearing handled programmatically
                                }
                            },
                            viewModeEnabled: true, // Start in view mode
                            zenModeEnabled: false,
                            gridModeEnabled: false,
                             // Store elements when they change (optional, useful for debugging)
                             onChange: (elements, appState) => {
                                 state.excalidrawElements = elements;
                             }
                        })
                    );
                    console.log("Excalidraw component mount initiated.");
                    return true;
                } catch (error) {
                    console.error("Error mounting Excalidraw:", error);
                    container.innerHTML = `<div class="loading-placeholder" style="color:var(--danger);"><i class="fas fa-exclamation-triangle"></i><p>Chyba Excalidraw:<br>${error.message}</p></div>`;
                    return false;
                }
            };

            /** Updates the Excalidraw scene with new elements. */
            const updateExcalidrawScene = (elements) => {
                if (!state.excalidrawAPI) {
                    console.warn("Excalidraw API not available for scene update.");
                    return;
                }
                console.log(`Updating Excalidraw scene with ${elements.length} elements.`);
                console.log("First few elements data (structure check):", elements.slice(0,2).map(el => ({type: el?.type, id: el?.id}))); // Check structure

                // Hide loading placeholder if still visible
                const placeholder = uiElements.excalidrawContainer?.querySelector('.loading-placeholder');
                if (placeholder) placeholder.style.display = 'none';

                try {
                    // Update the scene with the new elements
                    state.excalidrawAPI.updateScene({ elements: elements });
                    state.excalidrawElements = elements; // Update local state

                    // Scroll to content after a short delay to allow rendering
                    setTimeout(() => {
                        if (state.excalidrawAPI?.scrollToContent) {
                            const currentElements = state.excalidrawAPI.getSceneElements();
                            if (currentElements?.length > 0) {
                                console.log("Attempting to scroll to content...");
                                state.excalidrawAPI.scrollToContent(currentElements, { fitToContent: true, duration: 300 });
                            } else {
                                console.log("No elements to scroll to after update.");
                            }
                        } else {
                            console.warn("scrollToContent function not available on Excalidraw API.");
                        }
                    }, 200);
                } catch (error) {
                    console.error("Error updating Excalidraw scene inside updateScene call:", error);
                    showToast("Chyba při aktualizaci kreslící plochy.", "error");
                    // Log the problematic data for debugging
                    console.error("Data that likely caused the error:", elements);
                }
            };

            // --- User Profile & Authentication ---

            /** Loads the current user and their profile from Supabase. */
            const loadUserProfile = async () => {
                if (!state.supabase) return;
                try {
                    // Get user session
                    const { data: { user }, error: userError } = await state.supabase.auth.getUser();
                    if (userError) throw userError;

                    if (user) {
                        state.currentUser = user;
                        // Fetch profile details if user exists
                        const { data: profile, error: profileError } = await state.supabase
                            .from('profiles')
                            .select('*')
                            .eq('id', user.id)
                            .single(); // Expect only one profile

                        // Ignore 'No rows found' error (PGRST116), but throw others
                        if (profileError && profileError.code !== 'PGRST116') throw profileError;
                        state.currentProfile = profile; // Can be null if no profile found
                        console.log("User profile loaded:", state.currentProfile);
                    } else {
                        // No user session found
                        state.currentUser = null;
                        state.currentProfile = null;
                        console.log("No user logged in.");
                    }
                } catch (error) {
                    console.error('Error loading user profile:', error);
                    state.currentUser = null;
                    state.currentProfile = null;
                    showToast("Nepodařilo se načíst profil.", "error");
                } finally {
                    updateUserInfoUI(); // Update UI regardless of success/failure
                }
            };

            /** Updates the user avatar and name in the sidebar. */
            const updateUserInfoUI = () => {
                if (uiElements.userName && uiElements.userAvatar) {
                    if (state.currentProfile || state.currentUser) {
                        const email = state.currentUser?.email;
                        const initials = getInitials(state.currentProfile, email);
                        // Construct display name
                        const displayName = `${state.currentProfile?.first_name || ''} ${state.currentProfile?.last_name || ''}`.trim() || state.currentProfile?.username || email?.split('@')[0] || 'Uživatel';

                        uiElements.userName.textContent = displayName;
                        // Display avatar image or initials
                        if (state.currentProfile?.avatar_url) {
                            uiElements.userAvatar.innerHTML = `<img src="${state.currentProfile.avatar_url}" alt="${initials}">`;
                        } else {
                            uiElements.userAvatar.innerHTML = ''; // Clear image
                            uiElements.userAvatar.textContent = initials;
                        }
                    } else {
                        // Default display for logged-out user
                        uiElements.userName.textContent = 'Nepřihlášen';
                        uiElements.userAvatar.innerHTML = '?';
                    }
                }
            };

            /** Handles the UI and state when no user is logged in. */
            const handleLoggedOutUser = () => {
                console.warn("User not logged in.");
                updateAIStatus("Přihlaste se pro zahájení výuky.");
                if (uiElements.currentTopicDisplay) uiElements.currentTopicDisplay.innerHTML = '<span class="placeholder">Nejste přihlášeni</span>';
                showToast("Prosím, přihlaste se.", "warning");
                manageUIState('loggedOut'); // Set UI to logged-out state
                manageButtonStates(); // Disable buttons
                 // Ensure Excalidraw is in view mode if the user logs out during a session
                 if(state.excalidrawAPI?.updateScene) {
                      try { state.excalidrawAPI.updateScene({ appState: { viewModeEnabled: true }}); console.log("Excalidraw set to view mode (logged out)."); }
                      catch(e) { console.error("Error setting Excalidraw to view mode on logout:", e); }
                 }
            };

            // --- Event Listeners Setup ---

            /** Sets up all necessary event listeners for UI interactions. */
            const setupEventListeners = () => {
                console.log("Setting up event listeners...");

                // Mobile Menu Toggle
                if (uiElements.mobileMenuToggle && uiElements.sidebar && uiElements.sidebarOverlay) {
                    uiElements.mobileMenuToggle.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent click from closing menu immediately
                        uiElements.sidebar.classList.toggle('active');
                        uiElements.sidebarOverlay.classList.toggle('active');
                    });
                    uiElements.sidebarOverlay.addEventListener('click', () => {
                        uiElements.sidebar.classList.remove('active');
                        uiElements.sidebarOverlay.classList.remove('active');
                    });
                     // Close sidebar on clicking main content area
                     document.querySelector('main')?.addEventListener('click', () => {
                         if (uiElements.sidebar?.classList.contains('active')) {
                              uiElements.sidebar.classList.remove('active');
                              uiElements.sidebarOverlay.classList.remove('active');
                         }
                     });
                } else { console.warn("Mobile menu elements not found."); }

                // Interaction Panel Tabs
                if (uiElements.interactionTabs.length > 0 && uiElements.tabContents.length > 0) {
                    uiElements.interactionTabs.forEach(tab => {
                        tab.addEventListener('click', () => switchInteractionTab(tab.dataset.tab));
                    });
                } else { console.warn("Interaction tab elements not found."); }

                // Chat Input & Send Button
                if (uiElements.chatInput && uiElements.sendButton) {
                    uiElements.chatInput.addEventListener('input', autoResizeTextarea); // Auto-resize textarea
                    // Send message on Enter (but not Shift+Enter)
                    uiElements.chatInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter' && !e.shiftKey) {
                            e.preventDefault(); // Prevent new line
                            if (!state.geminiIsThinking) handleSendMessage(); // Send if AI is not busy
                        }
                    });
                    uiElements.sendButton.addEventListener('click', () => {
                        if (!state.geminiIsThinking) handleSendMessage(); // Send on button click
                    });
                } else { console.warn("Chat input/send elements not found."); }

                // Chat Controls
                if (uiElements.clearChatBtn) uiElements.clearChatBtn.addEventListener('click', confirmClearChat);
                if (uiElements.saveChatBtn) uiElements.saveChatBtn.addEventListener('click', saveChatToPDF);

                // Explanation Controls
                if (uiElements.nextStepBtn) uiElements.nextStepBtn.addEventListener('click', requestNextStep);
                if (uiElements.markCompleteBtn) uiElements.markCompleteBtn.addEventListener('click', handleMarkTopicComplete);

                // Window Resize (for mobile menu handling)
                window.addEventListener('resize', () => {
                    // Hide mobile overlay/menu if window becomes wider
                    if (window.innerWidth > 992 && uiElements.sidebar?.classList.contains('active')) {
                        uiElements.sidebar.classList.remove('active');
                        uiElements.sidebarOverlay.classList.remove('active');
                    }
                });
            };

            /** Initializes Tooltipster tooltips on elements with the 'btn-tooltip' class. */
            const initTooltips = () => {
                try {
                    // Check if jQuery and Tooltipster are loaded
                    if (window.jQuery && window.jQuery.fn.tooltipster) {
                        // Initialize tooltips only on elements that haven't been initialized yet
                        window.jQuery('.btn-tooltip:not(.tooltipstered)').tooltipster({
                            theme: 'tooltipster-shadow', // Use a theme
                            animation: 'fade',
                            delay: 100,
                            side: 'top' // Position tooltip above the button
                        });
                    } else { console.warn("jQuery or Tooltipster not fully loaded for initTooltips."); }
                } catch (e) { console.error("Tooltipster initialization error:", e); }
            };

            // --- Topic Loading and Progress ---

            /** Loads the next uncompleted activity from the user's active study plan. */
            const loadNextUncompletedTopic = async () => {
                // Prevent loading if already loading, no user, or Supabase not ready
                if (!state.currentUser || state.topicLoadInProgress || !state.supabase) {
                    console.log("Skipping topic load:", { loggedIn: !!state.currentUser, loading: state.topicLoadInProgress });
                    return;
                }
                state.topicLoadInProgress = true;
                if(state.excalidrawAPI?.updateScene) { // Ensure Excalidraw is view-only while loading
                     try { state.excalidrawAPI.updateScene({ appState: { viewModeEnabled: true }}); console.log("Excalidraw set to view mode (loading topic)."); }
                     catch (e) { console.error("Error setting Excalidraw to view mode:", e); }
                }
                if (uiElements.currentTopicDisplay) uiElements.currentTopicDisplay.innerHTML = '<span class="placeholder"><i class="fas fa-spinner fa-spin"></i> Hledám další téma...</span>';
                updateAIStatus('Hledám téma...');
                manageUIState('loadingTopic'); // Show loading state
                manageButtonStates(); // Disable buttons

                try {
                    // 1. Find the active study plan
                    const { data: activePlans, error: planError } = await state.supabase
                        .from('study_plans')
                        .select('id')
                        .eq('user_id', state.currentUser.id)
                        .eq('status', 'active') // Only active plans
                        .order('created_at', { ascending: false }) // Get the latest active plan
                        .limit(1);

                    if (planError) throw planError;

                    if (!activePlans || activePlans.length === 0) {
                        // No active plan found
                        console.log("No active study plan found.");
                        if (uiElements.currentTopicDisplay) uiElements.currentTopicDisplay.innerHTML = '<span class="placeholder">Žádný aktivní studijní plán</span>';
                        showToast("Nemáte aktivní studijní plán.", "warning");
                        updateAIStatus("Nemáte aktivní plán.");
                        manageUIState('noPlan'); // Update UI state
                        state.topicLoadInProgress = false;
                         if(state.excalidrawAPI?.updateScene) { // Keep view-only mode
                              try { state.excalidrawAPI.updateScene({ appState: { viewModeEnabled: true }}); console.log("Excalidraw set to view mode (no plan)."); }
                              catch (e) { console.error("Error setting Excalidraw to view mode:", e); }
                         }
                        return;
                    }
                    state.currentPlanId = activePlans[0].id;
                    console.log("Active plan ID:", state.currentPlanId);

                    // 2. Find the next uncompleted activity in this plan
                    const { data: nextActivities, error: activityError } = await state.supabase
                        .from('plan_activities')
                        .select('id, title, description, day_of_week, time_slot, topic_id, completed')
                        .eq('plan_id', state.currentPlanId)
                        .eq('completed', false) // Only uncompleted activities
                        .order('day_of_week', { ascending: true }) // Order by day, then time
                        .order('time_slot', { ascending: true })
                        .limit(1); // Get the very next one

                    if (activityError) throw activityError;

                    if (nextActivities && nextActivities.length > 0) {
                        // Found the next activity
                        const nextActivity = nextActivities[0];
                        console.log("Next activity found:", nextActivity);

                        // Prepare topic data (use activity title/desc, then try fetching topic details)
                        let topicName = nextActivity.title || 'Nespecifikované téma';
                        let topicDescription = nextActivity.description || '';

                        // If topic_id exists, try to fetch more details from exam_topics
                        if (nextActivity.topic_id) {
                            const { data: topicData, error: topicError } = await state.supabase
                                .from('exam_topics')
                                .select('name, description')
                                .eq('id', nextActivity.topic_id)
                                .single();

                            if (topicError && topicError.code !== 'PGRST116') { // Log errors other than 'not found'
                                console.warn(`Could not fetch topic details for ID ${nextActivity.topic_id}:`, topicError);
                            }
                            if (topicData) { // Update name/description if found
                                topicName = topicData.name || topicName;
                                topicDescription = topicData.description || topicDescription;
                            }
                        }

                        // Set the current topic state
                        state.currentTopic = {
                            activity_id: nextActivity.id,
                            plan_id: state.currentPlanId,
                            name: topicName,
                            description: topicDescription,
                            user_id: state.currentUser.id,
                            topic_id: nextActivity.topic_id // Store topic_id if available
                        };
                        console.log("Current topic set:", state.currentTopic);

                        // Update UI
                        if (uiElements.currentTopicDisplay) uiElements.currentTopicDisplay.innerHTML = `Aktuální téma: <strong>${sanitizeHTML(state.currentTopic.name)}</strong>`;
                        // Start the learning session for this topic
                        await startLearningSession();

                    } else {
                        // No more uncompleted activities in the plan
                        console.log("All activities completed.");
                        if (uiElements.currentTopicDisplay) uiElements.currentTopicDisplay.innerHTML = '<span class="placeholder">Gratulujeme, plán dokončen!</span>';
                        showToast("Všechna témata v plánu jsou dokončena!", "success");
                        updateAIStatus("Plán dokončen.");
                        manageUIState('planComplete'); // Update UI state
                         if(state.excalidrawAPI?.updateScene) { // Keep view-only mode
                              try { state.excalidrawAPI.updateScene({ appState: { viewModeEnabled: true }}); console.log("Excalidraw set to view mode (plan complete)."); }
                              catch (e) { console.error("Error setting Excalidraw to view mode:", e); }
                         }
                    }
                } catch (error) {
                    console.error('Error loading next topic:', error);
                    if (uiElements.currentTopicDisplay) uiElements.currentTopicDisplay.innerHTML = '<span class="placeholder" style="color:var(--danger);">Chyba</span>';
                    showToast(`Nepodařilo se načíst téma: ${error.message}`, "error");
                    updateAIStatus("Chyba načítání.");
                    manageUIState('error'); // Update UI state
                     if(state.excalidrawAPI?.updateScene) { // Keep view-only mode on error
                          try { state.excalidrawAPI.updateScene({ appState: { viewModeEnabled: true }}); console.log("Excalidraw set to view mode (load error)."); }
                          catch (e) { console.error("Error setting Excalidraw to view mode:", e); }
                     }
                } finally {
                    state.topicLoadInProgress = false; // Allow next load attempt
                    manageButtonStates(); // Re-enable buttons if appropriate
                }
            };

            /** Marks the current topic's activity as completed in the database and loads the next one. */
            const handleMarkTopicComplete = async () => {
                if (!state.currentTopic || !state.currentTopic.activity_id || !state.supabase || state.topicLoadInProgress) return;

                console.log(`Marking activity ${state.currentTopic.activity_id} as complete.`);
                state.topicLoadInProgress = true; // Prevent concurrent actions
                manageButtonStates(); // Disable buttons
                if(uiElements.markCompleteBtn) uiElements.markCompleteBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Ukládám...'; // Show loading state

                try {
                    // Update the activity status in the database
                    const { error } = await state.supabase
                        .from('plan_activities')
                        .update({ completed: true, updated_at: new Date().toISOString() })
                        .eq('id', state.currentTopic.activity_id);

                    if (error) throw error; // Throw error if update fails

                    showToast(`Téma "${state.currentTopic.name}" dokončeno.`, "success");

                    // Reset state for the next topic
                    state.currentTopic = null;
                    if (uiElements.currentTopicDisplay) uiElements.currentTopicDisplay.innerHTML = '<span class="placeholder">Načítám další...</span>';
                    if (uiElements.explanationDisplay) uiElements.explanationDisplay.innerHTML = ''; // Clear explanation
                    if (uiElements.chatMessages) uiElements.chatMessages.innerHTML = ''; // Clear chat
                    updateExcalidrawScene([]); // Clear Excalidraw
                    state.geminiChatContext = []; // Clear chat history for Gemini
                    state.lastExplanationTimestamp = 0; // Reset explanation step tracker
                    if(state.excalidrawAPI?.updateScene) { // Ensure Excalidraw is view-only for next load
                         try { state.excalidrawAPI.updateScene({ appState: { viewModeEnabled: true }}); console.log("Excalidraw set to view mode (topic complete)."); }
                         catch(e) { console.error("Error setting Excalidraw to view mode:", e); }
                    }

                    // Load the next topic
                    await loadNextUncompletedTopic();

                } catch (error) {
                    console.error(`Error marking activity ${state.currentTopic?.activity_id} complete:`, error);
                    showToast("Chyba při označování tématu.", "error");
                    state.topicLoadInProgress = false; // Allow retry
                    manageButtonStates(); // Re-enable buttons
                } finally {
                     // Reset button text even if loading next topic fails
                     if(uiElements.markCompleteBtn) uiElements.markCompleteBtn.innerHTML = '<i class="fas fa-check-circle"></i> Téma dokončeno';
                }
            };

            // --- Learning Session Management ---

            /** Starts a new learning session for the current topic. */
            const startLearningSession = async () => {
                // Ensure required state is present
                if (!state.currentTopic || !state.currentUser || !state.supabase) {
                    console.error("Cannot start session: Missing data.");
                    updateAIStatus('Chyba: Nelze zahájit výuku.');
                    manageUIState('error');
                    return;
                }

                console.log(`Starting session for: "${state.currentTopic.name}" (Activity ID: ${state.currentTopic.activity_id})`);
                state.currentSessionId = generateSessionId(); // Assign a new unique session ID
                updateAIStatus(`Vysvětluje: ${state.currentTopic.name}`);
                manageUIState('requestingExplanation'); // Show loading state for initial explanation
                manageButtonStates(); // Update button states

                // Reset UI elements for the new session
                if (uiElements.chatMessages) uiElements.chatMessages.innerHTML = '';
                state.geminiChatContext = []; // Clear Gemini context
                state.lastExplanationTimestamp = 0; // Reset explanation step counter
                updateExcalidrawScene([]); // Clear Excalidraw canvas

                // *** Enable Excalidraw Interaction ***
                if (state.excalidrawAPI?.updateScene) {
                    try {
                         // Switch Excalidraw from view-only to interactive mode
                         state.excalidrawAPI.updateScene({ appState: { viewModeEnabled: false } });
                         console.log("Excalidraw interaction enabled for new topic.");
                    } catch (apiError) {
                         console.error("Error enabling Excalidraw interaction via API:", apiError);
                    }
                } else {
                     console.warn("Excalidraw API not ready to enable interaction.");
                }
                 // *** End Enable Excalidraw ***

                // Request initial explanation from Gemini
                updateGeminiThinkingState(true);
                let initialPrompt = `Jako AI Tutor "Justax" začni vysvětlovat ZÁKLADY tématu "${state.currentTopic.name}" pro studenta 9. třídy ZŠ (přijímačky CERMAT).`;
                if (state.currentTopic.description) {
                    initialPrompt += ` Popis tématu pro kontext: "${state.currentTopic.description}".`;
                }
                initialPrompt += ` Buď podrobný, přátelský a postupuj krok za krokem. Toto je ÚPLNĚ PRVNÍ krok vysvětlení tohoto tématu. **POUŽIJ kreslící plochu (Excalidraw) k VIZUALIZACI základního konceptu NEBO k UKÁZCE jednoduchého PŘÍKLADU krok za krokem, pokud je to relevantní pro úvod.** Nenechávej tabuli prázdnou, pokud se nabízí vizuální vysvětlení nebo příklad. Pro vizualizaci můžeš na konec odpovědi přidat JSON data pro Excalidraw ve formátu \`EXCALIDRAW_SCENE: \`\`\`json [ ... ] \`\`\`\`. Ukonči odpověď KRÁTKÝM A VÝSTIŽNÝM souhrnem (max 1-2 věty, jako zápis do sešitu) pro zobrazení v chatu ve formátu: \`CHAT_SUMMARY: [Zde tvůj krátký souhrn]\`.`;

                await sendToGemini(initialPrompt, 'explanation'); // Send request to Gemini for the 'explanation' area
            };

            /** Switches between the 'explanation' and 'chat' tabs in the interaction panel. */
            const switchInteractionTab = (tabId) => {
                uiElements.interactionTabs.forEach(tab => tab.classList.toggle('active', tab.dataset.tab === tabId));
                uiElements.tabContents.forEach(content => content.classList.toggle('active', content.id === `${tabId}-content`));
                state.activeInteractionTab = tabId;
                sessionStorage.setItem('activeVyukaTab', tabId); // Save active tab to session storage
                console.log(`Switched to tab: ${tabId}`);
            };

            /** Requests the next step of the explanation from Gemini. */
            const requestNextStep = async () => {
                if (state.geminiIsThinking || !state.currentTopic) return; // Prevent if busy or no topic
                console.log("Requesting next step...");
                updateGeminiThinkingState(true); // Show thinking indicator
                manageButtonStates(); // Disable buttons

                // Construct prompt for the next step
                const prompt = `Pokračuj ve vysvětlování tématu "${state.currentTopic.name}". Naváž na předchozí krok. **DŮRAZNĚ POUŽIJ Excalidraw, zejména POKUD pokračuješ v řešení příkladu nebo vysvětluješ geometrický koncept, graf, apod.** Zobrazuj jednotlivé kroky výpočtů nebo konstrukce na tabuli. Nezapomeň na formát \`EXCALIDRAW_SCENE: \`\`\`json [ ... ] \`\`\`\` a na KRÁTKÝ A VÝSTIŽNÝ souhrn pro chat (CHAT_SUMMARY:).`;

                await sendToGemini(prompt, 'explanation'); // Send request for 'explanation' area
            };

            // --- Chat Functionality ---

            /** Adds a message bubble to the chat interface and optionally saves it to the database. */
            const addChatMessage = async (message, sender, saveToDb = true, timestamp = new Date()) => {
                if (!uiElements.chatMessages) return;

                const messageId = `msg-${Date.now()}-${Math.random().toString(16).substring(2, 8)}`;
                // Determine avatar initials based on sender
                const avatarInitial = sender === 'user' ? getInitials(state.currentProfile, state.currentUser?.email) : 'AI';

                // Create message elements
                const messageDiv = document.createElement('div');
                messageDiv.className = `chat-message ${sender === 'gemini' ? 'model' : sender}`; // Add 'model' or 'user' class
                messageDiv.id = messageId;

                const bubbleDiv = document.createElement('div');
                bubbleDiv.className = 'message-bubble';
                renderMarkdown(bubbleDiv, message); // Render message content as Markdown

                // Assemble message structure
                messageDiv.innerHTML = `<div class="message-avatar">${avatarInitial}</div>`; // Add avatar
                messageDiv.appendChild(bubbleDiv); // Add message bubble
                messageDiv.innerHTML += `<div class="message-timestamp">${formatTimestamp(timestamp)}</div>`; // Add timestamp

                // Append to chat container and scroll down
                uiElements.chatMessages.appendChild(messageDiv);
                uiElements.chatMessages.scrollTop = uiElements.chatMessages.scrollHeight;

                // Save to database if requested and conditions met
                if (saveToDb && state.supabase && state.currentUser && state.currentTopic && state.currentSessionId) {
                     const dataToSave = {
                          user_id: state.currentUser?.id || null,
                          session_id: state.currentSessionId,
                          topic_id: state.currentTopic?.topic_id || null, // Use topic_id if available
                          topic_name: state.currentTopic?.name || null,
                          role: sender === 'gemini' ? 'model' : 'user',
                          content: message // The raw message content
                     };
                     // Basic validation before saving
                     if (!dataToSave.session_id || !dataToSave.role || !dataToSave.content) {
                          console.error("Supabase chat save error: Missing required fields (session_id, role, content).", dataToSave);
                          showToast("Chyba: Nelze uložit zprávu, chybí data.", "error");
                          return;
                     }
                     console.log("Attempting to save chat message:", dataToSave);
                     try {
                          // Insert message into 'chat_history' table
                          const { error } = await state.supabase.from('chat_history').insert(dataToSave);
                          if (error) {
                               console.error("Supabase chat save error:", error);
                               console.error("Data sent:", dataToSave); // Log data that caused error
                               showToast(`Chyba ukládání chatu: ${error.message}`, 'error');
                          } else {
                               console.log("Chat message saved to DB.");
                          }
                     } catch (dbError) {
                          console.error("Exception during chat save:", dbError);
                          console.error("Data sent:", dataToSave); // Log data that caused error
                          showToast(`Výjimka při ukládání chatu: ${dbError.message}`, 'error');
                     }
                }
            };

            /** Updates the UI and state to indicate whether Gemini is processing a request. */
            const updateGeminiThinkingState = (isThinking) => {
                state.geminiIsThinking = isThinking;
                manageButtonStates(); // Update button enabled/disabled states
                if (isThinking) {
                    addThinkingIndicator(); // Show the "..." indicator in chat
                } else {
                    removeThinkingIndicator(); // Remove the indicator
                }
            };

            /** Adds a "thinking..." indicator bubble to the chat. */
            const addThinkingIndicator = () => {
                if (state.thinkingIndicatorId || !uiElements.chatMessages) return; // Prevent duplicates
                const indicatorDiv = document.createElement('div');
                indicatorDiv.className = 'chat-message model'; // Style as an AI message
                state.thinkingIndicatorId = `thinking-${Date.now()}`; // Generate unique ID
                indicatorDiv.id = state.thinkingIndicatorId;
                // HTML for the thinking bubble with animated dots
                indicatorDiv.innerHTML = `
                    <div class="message-avatar">AI</div>
                    <div class="message-thinking-indicator">
                        <span class="typing-dot"></span>
                        <span class="typing-dot"></span>
                        <span class="typing-dot"></span>
                    </div>`;
                uiElements.chatMessages.appendChild(indicatorDiv);
                uiElements.chatMessages.scrollTop = uiElements.chatMessages.scrollHeight; // Scroll to show indicator
            };

            /** Removes the "thinking..." indicator bubble from the chat. */
            const removeThinkingIndicator = () => {
                if (state.thinkingIndicatorId) {
                    const indicator = document.getElementById(state.thinkingIndicatorId);
                    if (indicator) indicator.remove(); // Remove the element
                    state.thinkingIndicatorId = null; // Reset the ID
                }
            };

            /** Handles sending a user message from the chat input. */
            const handleSendMessage = async () => {
                const messageText = uiElements.chatInput.value.trim();
                // Prevent sending empty messages or if AI is busy or no topic is active
                if (!messageText || state.geminiIsThinking || !state.currentTopic) return;

                // Clear input, resize, and focus
                uiElements.chatInput.value = '';
                autoResizeTextarea();
                uiElements.chatInput.focus();

                const userTimestamp = new Date();
                // Add user message to UI and DB
                await addChatMessage(messageText, 'user', true, userTimestamp);
                // Add user message to Gemini's context history
                state.geminiChatContext.push({ role: "user", parts: [{ text: messageText }] });

                updateGeminiThinkingState(true); // Show thinking indicator
                // Send message to Gemini for the 'chat' area
                await sendToGemini(messageText, 'chat');
            };

             /** Prompts the user to confirm clearing the chat history. */
             const confirmClearChat = () => {
                if (confirm("Opravdu chcete vymazat historii tohoto chatu a kresbu?\nTato akce je nevratná.")) {
                    clearCurrentChatSessionHistory();
                }
            };

            /** Clears the chat UI, context, Excalidraw, and optionally deletes history from DB for the current session. */
            const clearCurrentChatSessionHistory = async () => {
                 // Clear UI elements
                 if (uiElements.chatMessages) uiElements.chatMessages.innerHTML = '';
                 state.geminiChatContext = []; // Clear context for Gemini
                 updateExcalidrawScene([]); // Clear Excalidraw canvas
                 showToast("Historie chatu a kresba vymazána.", "info");
                 console.log("Chat history and Excalidraw cleared for this session.");

                 // Delete from Database if possible
                 if (state.supabase && state.currentUser && state.currentSessionId) {
                     try {
                         console.log(`Deleting chat history from DB for session: ${state.currentSessionId}`);
                         // Delete records matching user_id and session_id
                         const { error } = await state.supabase
                             .from('chat_history')
                             .delete()
                             .eq('user_id', state.currentUser.id)
                             .eq('session_id', state.currentSessionId);

                         if (error) {
                             // Log and notify user about DB error
                             console.error("Error deleting chat history from DB:", error);
                             showToast("Chyba při mazání historie z databáze.", "error");
                         } else {
                             console.log("Chat history deleted from DB.");
                             // Optional: Could add a success toast here if needed
                         }
                     // *** THIS IS THE CORRECTED BLOCK ***
                     } catch (dbError) { // Catch any exceptions during the DB operation
                         console.error("Exception during DB chat history deletion:", dbError);
                         // Optionally show a different toast for exceptions
                         showToast("Nastala výjimka při mazání historie z DB.", "error");
                     }
                     // *** END OF CORRECTED BLOCK ***
                 }
            };


            /** Saves the current chat conversation to a PDF file. */
            const saveChatToPDF = async () => {
                 // Check if there are any messages to save
                if (!uiElements.chatMessages || uiElements.chatMessages.children.length === 0) {
                    showToast("Není co uložit.", "warning");
                    return;
                }

                showToast("Generuji PDF...", "info", 2000); // Indicate PDF generation start

                // Create a container for PDF content
                const chatContainer = document.createElement('div');
                chatContainer.id = "pdf-export-content";

                // Define basic CSS styles for the PDF
                const pdfStyles = `
                <style>
                    body { font-family: 'Poppins', sans-serif; font-size: 10pt; line-height: 1.5; }
                    .pdf-header { text-align: center; margin-bottom: 15px; border-bottom: 1px solid #ccc; padding-bottom: 10px; }
                    .chat-message { margin-bottom: 10px; max-width: 85%; }
                    /* Align user messages to the right */
                    .chat-message.user { margin-left: 15%; text-align: right; }
                    /* Align model messages to the left */
                    .chat-message.model { margin-right: 15%; text-align: left;}
                    /* Style the message bubble */
                    .message-bubble { padding: 8px 12px; border-radius: 10px; background-color: #f1f1f1; display: inline-block; border: 1px solid #eee; text-align: left; /* Ensure text inside is left-aligned */ }
                    .chat-message.user .message-bubble { background-color: #e1ffc7; } /* Different background for user */
                    /* Style the timestamp */
                    .message-timestamp { font-size: 8pt; color: #888; margin-top: 3px; display: block; }
                    .chat-message.user .message-timestamp { text-align: right; } /* Align user timestamp right */
                    /* Basic code styling */
                    code { font-family: monospace; background-color: #eee; padding: 1px 3px; border-radius: 3px; }
                    pre { margin: 5px 0;}
                    pre code { display: block; padding: 8px; background-color: #f8f8f8; border: 1px solid #ddd; border-radius: 4px; white-space: pre-wrap; word-wrap: break-word; text-align: left; }
                </style>
                `;
                chatContainer.innerHTML = pdfStyles;

                // Add a header to the PDF
                const headerDiv = document.createElement('div');
                headerDiv.className = 'pdf-header';
                headerDiv.innerHTML = `<h1>Záznam chatu - ${sanitizeHTML(state.currentTopic?.name || 'Neznámé téma')}</h1><p>Exportováno: ${new Date().toLocaleString('cs-CZ')}</p>`;
                chatContainer.appendChild(headerDiv);

                // Clone chat messages into the PDF container, removing avatars
                Array.from(uiElements.chatMessages.children).forEach(msgElement => {
                    if (msgElement.classList.contains('chat-message')) {
                        const clone = msgElement.cloneNode(true);
                        const avatar = clone.querySelector('.message-avatar');
                        if(avatar) avatar.remove(); // Remove avatar element for PDF
                        chatContainer.appendChild(clone);
                    }
                });

                // Generate filename
                const filename = `chat-justax-${state.currentTopic?.name?.replace(/[^a-z0-9]/gi, '_') || 'vyuka'}-${formatTimestamp().replace(/[:\s]/g, '')}.pdf`;

                // Configure html2pdf options
                const options = {
                    margin: 15,
                    filename: filename,
                    image: { type: 'jpeg', quality: 0.95 },
                    html2canvas: { scale: 2, useCORS: true, logging: false, letterRendering: true },
                    jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' }
                };

                // Generate and save the PDF
                try {
                    await html2pdf().set(options).from(chatContainer).save();
                    showToast("Chat uložen jako PDF!", "success");
                } catch (pdfError) {
                    console.error("Chyba exportu PDF:", pdfError);
                    showToast("Nepodařilo se exportovat chat do PDF.", "error");
                }
            };


            // --- Gemini Interaction & Excalidraw Processing ---

            /** Extracts Excalidraw JSON data from Gemini's response text. */
            const parseExcalidrawScene = (responseText) => {
                console.log("Attempting to parse Excalidraw scene data...");
                EXCALIDRAW_SCENE_REGEX.lastIndex = 0; // Reset regex index
                const match = EXCALIDRAW_SCENE_REGEX.exec(responseText);
                let sceneData = null;
                let cleanedText = responseText; // Start with the original text

                if (match && match[1]) { // If JSON block is found
                    console.log("Found EXCALIDRAW_SCENE block.");
                    try {
                        // Clean up potential trailing commas before closing brackets/braces
                        let jsonString = match[1].trim().replace(/,\s*([}\]])/g, '$1');
                        sceneData = JSON.parse(jsonString); // Parse the JSON string

                        // Basic validation: ensure it's an array
                        if (!Array.isArray(sceneData)) {
                            console.warn("Parsed Excalidraw data is not an array:", sceneData);
                            sceneData = null; // Invalidate if not an array
                        } else {
                            console.log(`Successfully parsed ${sceneData.length} Excalidraw elements.`);
                            // Remove the matched JSON block from the text
                            cleanedText = cleanedText.replace(match[0], '').trim();
                        }
                    } catch (e) {
                        // Handle JSON parsing errors
                        console.error("Failed to parse Excalidraw JSON:", e, "\nJSON String (Attempted):", match[1]);
                        cleanedText = responseText; // Keep original text if parsing fails
                        sceneData = null;
                    }
                } else {
                    console.log("No EXCALIDRAW_SCENE block found.");
                }
                return { cleanedText, sceneData }; // Return cleaned text and parsed data (or null)
            };

             /** Validates the structure and types of Excalidraw element properties. */
             const validateExcalidrawElements = (elements) => {
                if (!Array.isArray(elements)) {
                    console.error("Validation failed: Input is not an array.");
                    return { isValid: false, invalidElements: [] };
                }

                const invalidElements = [];
                // Define required properties for common element types
                const requiredProps = {
                    text: ['type', 'x', 'y', 'width', 'height', 'text', 'fontSize', 'fontFamily'],
                    line: ['type', 'x', 'y', 'width', 'height', 'points'],
                    arrow: ['type', 'x', 'y', 'width', 'height', 'points'],
                    rectangle: ['type', 'x', 'y', 'width', 'height'],
                    ellipse: ['type', 'x', 'y', 'width', 'height']
                };
                const numericProps = ['x', 'y', 'width', 'height', 'angle', 'strokeWidth', 'fontSize']; // Properties that should be numbers

                elements.forEach((el, index) => {
                    let isValidElement = true;
                    // Basic check: must be an object with a 'type'
                    if (typeof el !== 'object' || el === null || !el.type) {
                        invalidElements.push({ index, element: el, reason: "Not object or missing type" });
                        return; // Skip further checks for this invalid element
                    }

                    // Check for required properties based on type
                    const propsToCheck = requiredProps[el.type] || ['type', 'x', 'y', 'width', 'height']; // Default check for basic shapes
                    for (const prop of propsToCheck) {
                        if (el[prop] === undefined) {
                            isValidElement = false;
                            break;
                        }
                    }
                    if (!isValidElement) {
                        invalidElements.push({ index, element: el, reason: "Missing required properties" });
                        return;
                    }

                    // Check numeric properties
                    for (const prop of numericProps) {
                        if (el[prop] !== undefined && typeof el[prop] !== 'number') {
                            isValidElement = false;
                            break;
                        }
                    }
                     if (!isValidElement) {
                        invalidElements.push({ index, element: el, reason: `Non-numeric property (${prop})` }); // Specify the invalid property
                        return;
                     }

                    // Specific checks for line/arrow points
                    if (['line', 'arrow'].includes(el.type)) {
                        if (!Array.isArray(el.points) || el.points.length < 2) {
                            isValidElement = false;
                        } else {
                            // Check if points are arrays of two numbers
                            const hasInvalidPoint = el.points.some(p => !Array.isArray(p) || p.length !== 2 || typeof p[0] !== 'number' || typeof p[1] !== 'number');
                            if (hasInvalidPoint) {
                                isValidElement = false;
                            }
                        }
                    }

                    // Add to invalid list if any check failed and not already added
                    if (!isValidElement && !invalidElements.some(inv => inv.index === index)) {
                        invalidElements.push({ index, element: el, reason: "Specific property validation failed (e.g., points)" });
                    }
                });

                const overallIsValid = invalidElements.length === 0;
                if (!overallIsValid) {
                    console.error(`Excalidraw data validation failed. Found ${invalidElements.length} invalid elements.`, invalidElements);
                } else {
                    console.log("Excalidraw data validation successful.");
                }
                return { isValid: overallIsValid, invalidElements };
            };


            /** Adds missing default properties to Excalidraw elements to prevent rendering errors. */
            const addDefaultExcalidrawProps = (elements) => {
                if (!Array.isArray(elements)) return elements; // Return as is if not an array
                console.log("Patching Excalidraw elements with default properties...");
                return elements.map(el => {
                     // Skip if element is not a valid object
                    if (typeof el !== 'object' || el === null) return el;

                    // Common default properties for most elements
                    const defaults = {
                        angle: 0,
                        fillStyle: 'hachure', // Default fill style
                        strokeWidth: 1,
                        strokeStyle: 'solid',
                        roughness: 0, // Make lines clean
                        opacity: 100,
                        seed: el.seed ?? Math.floor(Math.random() * 2 ** 31), // Use existing or generate random seed
                        version: el.version ?? 1, // Default version
                        versionNonce: el.versionNonce ?? Math.floor(Math.random() * 2 ** 31), // Use existing or generate nonce
                        isDeleted: false,
                        boundElements: el.boundElements ?? null,
                        updated: el.updated ?? Date.now(), // Use existing or set current time
                        link: el.link ?? null,
                        locked: el.locked ?? false,
                        groupIds: el.groupIds ?? [],
                        frameId: el.frameId ?? null,
                        roundness: el.roundness ?? null, // Important for shapes
                        startBinding: el.startBinding ?? null,
                        endBinding: el.endBinding ?? null,
                        startArrowhead: el.startArrowhead ?? null, // Default no arrowhead
                        endArrowhead: el.endArrowhead ?? null   // Default no arrowhead
                    };

                    // Type-specific defaults
                    if (el.type === 'text') {
                        defaults.textAlign = el.textAlign ?? 'left';
                        defaults.verticalAlign = el.verticalAlign ?? 'top';
                        defaults.baseline = el.baseline ?? 18; // Common baseline value
                    }
                    if (['rectangle', 'ellipse', 'diamond'].includes(el.type)) {
                        defaults.backgroundColor = el.backgroundColor ?? 'transparent'; // Default no background
                        defaults.strokeSharpness = el.strokeSharpness ?? (el.type === 'rectangle' ? 'sharp' : 'round');
                    }
                    if (['line', 'arrow'].includes(el.type)) {
                        defaults.points = Array.isArray(el.points) ? el.points : []; // Ensure points is an array
                        defaults.lastCommittedPoint = el.lastCommittedPoint ?? null;
                         // Set default arrowheads (only end for 'arrow')
                        defaults.startArrowhead = el.startArrowhead ?? null;
                        defaults.endArrowhead = el.endArrowhead ?? (el.type === 'arrow' ? 'arrow' : null);
                    }

                    // Merge defaults with the existing element, letting existing properties override defaults
                    return { ...defaults, ...el };
                });
            };

            /** Processes the raw response from Gemini, extracts text, chat summary, and Excalidraw data, then updates the UI. */
            const processGeminiResponse = (rawResponseText, targetArea, timestamp) => {
                removeThinkingIndicator(); // Hide the "thinking" bubble

                let chatSummary = null;
                // Regex to find CHAT_SUMMARY: at the end of the response
                const summaryRegex = /CHAT_SUMMARY:\s*([\s\S]*)/;
                const summaryMatch = rawResponseText.match(summaryRegex);
                let textForProcessing = rawResponseText;

                // Extract chat summary if found
                if (summaryMatch && summaryMatch[1]) {
                    chatSummary = summaryMatch[1].trim();
                    // Remove the summary part from the main text
                    textForProcessing = rawResponseText.replace(summaryRegex, '').trim();
                    console.log("Extracted Chat Summary:", chatSummary);
                }

                // Parse Excalidraw scene data and get cleaned text
                let { cleanedText, sceneData } = parseExcalidrawScene(textForProcessing);
                let sceneUpdateAttempted = false;
                let sceneDataIsValid = false;

                if (sceneData) { // If Excalidraw data was found
                     sceneUpdateAttempted = true;
                     sceneData = addDefaultExcalidrawProps(sceneData); // Add default properties
                     const validationResult = validateExcalidrawElements(sceneData); // Validate structure
                     sceneDataIsValid = validationResult.isValid;

                     if (!sceneDataIsValid) {
                          // Handle invalid Excalidraw data
                          console.error("Excalidraw Validation Failed (after patching):", validationResult.invalidElements);
                          showToast("Chyba: AI vrátila neplatná data pro kresbu (i po úpravě).", "error");
                          // Add an error message to the chat
                          addChatMessage("Omlouvám se, nastal problém s daty pro kreslící plochu (i po úpravě).", 'gemini', false, new Date());
                     } else {
                          // Log valid data before updating the scene (for debugging)
                          console.log("--- Patched & Valid Scene Data (Pre-Update) ---");
                          try { console.log(JSON.stringify(sceneData, null, 2)); }
                          catch (e) { console.error("Error stringifying patched sceneData:", e); console.log("Patched Scene Data (raw):", sceneData); }
                          console.log("--- Attempting updateExcalidrawScene with patched data ---");
                          // Update the Excalidraw canvas
                          updateExcalidrawScene(sceneData);
                     }
                }

                // Determine which text goes where
                const textToDisplayInExplanation = cleanedText; // The main text (without summary/scene) goes to explanation
                const textToDisplayInChat = chatSummary || (targetArea === 'chat' ? cleanedText : null); // Use summary if available, otherwise cleaned text only if target was chat

                // Update Explanation Tab
                if (targetArea === 'explanation') {
                    console.log("Processing for EXPLANATION area.");
                    // Remove placeholder/empty state if present
                    const placeholder = uiElements.explanationDisplay.querySelector('.loading-placeholder, .empty-state');
                    if (placeholder) placeholder.remove();

                    // Clear display only if it's the very first step
                    const isFirstStep = !uiElements.explanationDisplay.querySelector('.step');
                    if (isFirstStep) { uiElements.explanationDisplay.innerHTML = ''; }

                    // Append the new explanation step if there's text content
                    if (textToDisplayInExplanation.trim()) {
                        const stepDiv = document.createElement('div');
                        stepDiv.className = 'step';
                        renderMarkdown(stepDiv, textToDisplayInExplanation); // Render Markdown
                        uiElements.explanationDisplay.appendChild(stepDiv);
                        state.lastExplanationTimestamp = Date.now(); // Track last step time

                        // Scroll to the newly added step
                        if (uiElements.explanationScrollContent) {
                            setTimeout(() => stepDiv.scrollIntoView({ behavior: "smooth", block: "end" }), 100);
                        }
                    } else {
                        console.log("No main text content for explanation step.");
                    }

                    // Add chat summary (if any) or a generic message to the chat tab
                    if (chatSummary) {
                        addChatMessage(chatSummary, 'gemini', true, timestamp);
                    } else if (textToDisplayInExplanation.trim() || (sceneUpdateAttempted && sceneDataIsValid)) {
                        // If explanation text or valid drawing was added, notify in chat
                        addChatMessage(`AI pokračovala ve vysvětlení ${sceneUpdateAttempted && sceneDataIsValid ? 'a aktualizovala kresbu' : ''}. Celý text je v záložce Vysvětlení.`, 'gemini', false, timestamp);
                    }

                    manageUIState('learning'); // Set UI state back to 'learning'
                    manageButtonStates(); // Re-enable buttons
                }
                // Update Chat Tab
                else { // targetArea === 'chat'
                    console.log("Processing for CHAT area.");
                    if (textToDisplayInChat && textToDisplayInChat.trim()) {
                        // Add the chat response (summary or cleaned text)
                        addChatMessage(textToDisplayInChat, 'gemini', true, timestamp);
                    } else if (!textToDisplayInChat && sceneUpdateAttempted && sceneDataIsValid) {
                        // If only drawing was updated, add a note
                        addChatMessage("(Aktualizoval(a) jsem kresbu podle tvého dotazu.)", 'gemini', false, timestamp);
                    } else if (!textToDisplayInChat && !(sceneUpdateAttempted && sceneDataIsValid)) {
                        // If response was empty and no valid drawing
                        addChatMessage("(AI neposkytla textovou odpověď ani platnou kresbu)", 'gemini', false, timestamp);
                        console.warn("AI chat response was empty, no summary, and no valid scene data found.");
                    }
                }

                // Trigger MathJax typesetting after updating the DOM
                if (window.MathJax && typeof window.MathJax.typesetPromise === 'function') {
                    setTimeout(() => { // Use setTimeout to ensure DOM updates are processed
                        console.log("MathJax: Queuing typeset after Gemini response processing.");
                        window.MathJax.typesetPromise()
                           .then(() => console.log("MathJax: Typesetting complete after Gemini response."))
                           .catch(err => console.error('MathJax typesetting error after Gemini:', err));
                    }, 150); // Delay slightly
                }
            };


            /** Sends a prompt to the Gemini API and handles the response. */
            const sendToGemini = async (promptText, targetArea) => {
                // Basic checks before sending
                if (!GEMINI_API_KEY || !GEMINI_API_KEY.startsWith('AIzaSy')) { // Basic check for valid-looking key
                     showToast("Chyba: AI není správně nakonfigurována (chybný API klíč).", "error");
                     updateGeminiThinkingState(false);
                     return;
                 }
                if (!state.currentTopic) {
                    showToast("Chyba: Není vybráno žádné téma.", "error");
                    updateGeminiThinkingState(false);
                    return;
                }

                console.log(`Sending to Gemini (Target: ${targetArea}): "${promptText.substring(0, 100)}..."`);
                updateAIStatus('AI přemýšlí...'); // Update status display
                const requestTimestamp = new Date(); // Record time of request
                updateGeminiThinkingState(true); // Set thinking state, disable buttons

                 // --- Construct System Instruction (Persona & Rules) ---
                 // This tells the AI how to behave
                 const systemInstructionText = `Jsi AI Tutor "Justax", expert na matematiku pro 9. třídu ZŠ v ČR (přijímačky CERMAT). Vyučuješ téma: "${state.currentTopic.name}"${state.currentTopic.description ? ` (Popis: "${state.currentTopic.description}")` : ''}. Tvůj styl je PŘÁTELSKÝ, TRPĚLIVÝ a PODROBNÝ. Vysvětluj krok za krokem, používej PŘESNÉ matematické termíny a jednoduché příklady. Důsledně používej Markdown pro formátování textu a MathJax pro matematické vzorce (blokové vzorce: $$...$$, inline vzorce: $...$ nebo \\(...\\)). Odpovídej VŽDY ČESKY.

 DŮLEŽITÉ POKYNY PRO TEBE:
 1.  **KROK ZA KROKEM:** V záložce "Vysvětlení" se drž JEDNOHO logického kroku nebo konceptu na odpověď. Buď systematický a postupný. Nezahlcuj studenta příliš mnoha informacemi najednou.
 2.  **INTERAKTIVITA:** Pravidelně pokládej studentovi KONTROLNÍ OTÁZKY nebo ho vyzývej k zamyšlení.
 3.  **VIZUALIZACE S EXCALIDRAW (KLÍČOVÉ PRO PŘÍKLADY):**
     * **AKTIVNĚ a ČASTO POUŽÍVEJ EXCALIDRAW**, PŘEDEVŠÍM k **ŘEŠENÍ KONKRÉTNÍCH PŘÍKLADŮ KROK ZA KROKEM**. Je to tvůj hlavní nástroj pro názorné ukázky výpočtů a postupů. Nenechávej tabuli prázdnou, pokud vysvětluješ něco, co lze ukázat na příkladu!
     * Použij Excalidraw také pro geometrické náčrty, grafy, číselné osy, zápisy vzorců apod., POKUD to přímo souvisí s vysvětlovaným krokem.
     * **FORMÁT:** Na KONEC textové odpovědi přidej JSON data pro Excalidraw: \`EXCALIDRAW_SCENE: \`\`\`json [ { /* element 1 */ }, ... ] \`\`\`\`. JSON musí být VALIDNÍ.
     * **OBSAH KRESBY (DŮLEŽITÉ):**
         * **PŘÍKLADY:** Zapiš zadání a **JEDNOTLIVÉ KROKY ŘEŠENÍ** jasně a čitelně. Použij textové elementy. Šipkami můžeš naznačit návaznost kroků. Buď EXPLICITNÍ v zobrazování kroků.
         * **ČITELNOST:** Použij **ČERNOU** nebo **TMAVĚ MODROU** barvu pro hlavní text a výpočty (#000000 nebo #1E3A8A). Pro zvýraznění můžeš použít **TMAVĚ ČERVENOU** (#DC2626) nebo **TMAVĚ ZELENOU** (#16A34A), ale střídmě. Pozadí VŽDY NECH BÍLÉ (#ffffff).
         * **FONT:** Použij výchozí font (Virgil - fontFamily: 1) nebo čitelný Helvetica (fontFamily: 2). Velikost písma (fontSize) zvol přiměřenou (např. 20 nebo 28), aby byla dobře vidět.
         * **STRUKTURA:** Kresli PŘEHLEDNĚ. Nepřekrývej prvky. Nový krok řešení umísti pod předchozí nebo vedle něj.
         * **JEDNODUCHOST:** Používej základní tvary (text, line, arrow, rectangle, ellipse). Parametr 'roughness' nastav na 0 pro čisté linie.
         * **AKTUALIZACE:** Pošli VŽDY KOMPLETNÍ scénu pro daný krok (včetně prvků z předchozích kroků, pokud mají zůstat viditelné). Pro smazání tabule pošli prázdné pole \`[]\`.
         * **TEXT V KRESBĚ:** Textové elementy ('type': 'text') jsou klíčové pro zápis kroků řešení. Použij \`\\n\` pro nový řádek v textu.
         * **PŘÍKLAD KROKU ŘEŠENÍ ROVNICE:** \`{ "type": "text", "x": 20, "y": 100, "width": 300, "height": 60, "text": "2. Odečteme 5 od obou stran:\\n   2x + 5 - 5 = 11 - 5\\n   2x = 6", "fontSize": 20, "fontFamily": 1, "strokeColor": "#000000", "textAlign": "left", "roughness": 0 }\`
 4.  **DÉLKA ODPOVĚDI:** Vysvětlení může být delší, ale členěné. Chatové odpovědi stručné.
 5.  **VÝSTUP DO CHATU (SHRNUTÍ):** POKUD generuješ delší odpověď pro "Vysvětlení", na ÚPLNÝ konec celé odpovědi (i za případný EXCALIDRAW_SCENE blok) PŘIDEJ **KRÁTKÝ A VÝSTIŽNÝ** souhrn (max 1-2 věty, jako zápis do sešitu) pro zobrazení v chatu: \`CHAT_SUMMARY: [Zde tvůj krátký souhrn]\`.`;
                 // --- End System Instruction ---

                 // Filter chat history for API (only user and model roles)
                const historyForApi = state.geminiChatContext.filter(item => item.role === 'user' || item.role === 'model');
                const currentRequestContent = { role: "user", parts: [{ text: promptText }] };

                // Construct the 'contents' payload for the Gemini API
                let contentsPayload;
                // Define the base system instruction part
                const baseSystemInstruction = [{ role: "user", parts: [{ text: systemInstructionText }] }];

                 // Special handling for the very first request in an explanation session
                 if (historyForApi.length === 0 && targetArea === 'explanation') {
                     // Provide a priming turn for the model
                      contentsPayload = [
                           ...baseSystemInstruction, // Start with system instruction
                           { role: "model", parts: [{ text: "Rozumím. Jsem připraven začít vysvětlovat." }] }, // Model priming
                           { role: "user", parts: [{ text: "Studentův požadavek (první krok): " + promptText }] } // The actual user request
                      ];
                 } else {
                      // For subsequent requests or chat, include history
                      contentsPayload = [
                           ...baseSystemInstruction, // Start with system instruction
                           { role: "model", parts: [{ text: "Pokračuji..." }] }, // General model priming
                           ...historyForApi, // Include previous turns
                           currentRequestContent // Add the current user request
                      ];
                 }


                // Define the full request body for the API
                const requestBody = {
                    contents: contentsPayload,
                    generationConfig: {
                        temperature: 0.5, // Lower temperature for more predictable explanations
                        topP: 0.95,
                        topK: 40,
                        maxOutputTokens: 8192 // Max output length
                    },
                    // Relax safety settings slightly for mathematical content if needed (adjust carefully)
                    safetySettings: [
                         { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
                         { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
                         { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
                         { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" },
                    ]
                };

                try {
                    console.log("Sending payload to Gemini:", JSON.stringify(requestBody).substring(0, 500) + "..."); // Log truncated payload
                    // Make the API call
                    const response = await fetch(GEMINI_API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(requestBody)
                    });

                    // Handle API errors (non-200 status)
                    if (!response.ok) {
                        const errorBody = await response.text();
                        console.error("Gemini API Error Response:", response.status, errorBody);
                        throw new Error(`Chyba Gemini API (${response.status}): ${errorBody.substring(0, 100)}`); // Throw truncated error
                    }

                    // Parse the successful JSON response
                    const data = await response.json();
                    console.log("Raw Gemini Response (first 300 chars):", JSON.stringify(data).substring(0, 300) + "...");

                     // --- Process Response ---
                     const candidate = data.candidates?.[0]; // Get the first candidate

                     // Check for valid candidate structure
                     if (!candidate) {
                         console.error("Invalid response structure from Gemini:", data);
                         const promptFeedback = data.promptFeedback;
                         // Check for content blocking feedback
                         if (promptFeedback?.blockReason) {
                              throw new Error(`Obsah blokován: ${promptFeedback.blockReason}. Detail: ${promptFeedback.safetyRatings?.map(r => `${r.category}: ${r.probability}`).join(', ')}`);
                         }
                         throw new Error('Chybná struktura odpovědi od AI.');
                     }
                      // Check if generation stopped for reasons other than normal STOP or MAX_TOKENS
                      if (candidate.finishReason && !["STOP", "MAX_TOKENS"].includes(candidate.finishReason)) {
                          console.warn(`Gemini generation stopped unexpectedly: ${candidate.finishReason}`);
                          // Potentially throw an error or handle differently if needed
                      }

                     // Extract the response text
                     const geminiResponseText = candidate.content?.parts?.[0]?.text;
                     if (!geminiResponseText) {
                         console.warn("Gemini returned empty text content.");
                         throw new Error('AI vrátila prázdnou odpověď.');
                     }

                    // Add both user prompt and model response to the context history
                    state.geminiChatContext.push({ role: "user", parts: [{ text: promptText }] });
                    state.geminiChatContext.push({ role: "model", parts: [{ text: geminiResponseText }] });

                    // Process the response to update UI (explanation, chat, Excalidraw)
                    processGeminiResponse(geminiResponseText, targetArea, requestTimestamp);
                    updateAIStatus(state.currentTopic ? `Vysvětluje: ${state.currentTopic.name}` : 'Připraven'); // Update status

                } catch (error) {
                    console.error('Error sending/processing Gemini request:', error);
                    showToast(`Chyba komunikace s AI: ${error.message}`, "error");
                    handleGeminiError(error.message, targetArea, requestTimestamp); // Show error in UI
                    updateAIStatus('Nastala chyba'); // Update status
                } finally {
                    updateGeminiThinkingState(false); // Ensure thinking state is reset
                }
            };

             /** Handles errors during Gemini API interaction by displaying messages in the UI. */
            const handleGeminiError = (errorMessage, targetArea, timestamp) => {
                const errorMsg = `Omlouvám se, nastala chyba při zpracování: ${errorMessage}`;
                removeThinkingIndicator(); // Ensure indicator is removed
                // Add error message to chat
                addChatMessage(errorMsg, 'gemini', false, timestamp);

                // If the error occurred during an explanation step, also add it to the explanation area
                if (targetArea === 'explanation' && uiElements.explanationDisplay) {
                    const errorP = document.createElement('p');
                    errorP.style.color = 'var(--danger)';
                    errorP.style.marginTop = '1rem';
                    errorP.style.fontWeight = 'bold';
                    errorP.textContent = errorMsg;
                    uiElements.explanationDisplay.appendChild(errorP);
                     // Scroll to the error message
                     if(uiElements.explanationScrollContent) {
                         uiElements.explanationScrollContent.scrollTop = uiElements.explanationScrollContent.scrollHeight;
                     }
                }
                updateAIStatus('Nastala chyba'); // Update status text
                manageButtonStates(); // Re-enable buttons after error
            };

            // --- Run Application ---
            // Add listener to run initializeApp when the DOM is fully loaded
            document.addEventListener('DOMContentLoaded', initializeApp);

        } catch (e) {
            // --- Fatal Error Handling ---
            // Catch any unexpected errors during script execution
            console.error("FATAL SCRIPT ERROR:", e);
            // Display a critical error message to the user, replacing the entire page content
            document.body.innerHTML = `<div style="padding: 30px; text-align: center; font-family: sans-serif; color: #dc3545;"><h1>Nastala kritická chyba</h1><p>Omlouváme se, aplikace nemohla být spuštěna.</p><p>Zkuste prosím obnovit stránku.</p><pre style="margin-top: 20px; padding: 15px; background-color: #f8d7da; border: 1px solid #f5c6cb; border-radius: 5px; text-align: left; font-size: 12px; white-space: pre-wrap; word-wrap: break-word;">${e.message}\n${e.stack}</pre></div>`;
        }
    </script>

</body>
</html>